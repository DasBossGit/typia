{"/docs":{"title":"Index","data":{"outline#Outline":"// RUNTIME VALIDATORS\r\nexport function is<T>(input: unknown): input is T; // returns boolean\r\nexport function assert<T>(input: unknown): T; // throws TypeGuardError\r\nexport function assertGuard<T>(input: unknown): asserts input is T;\r\nexport function validate<T>(input: unknown): IValidation<T>; // detailed\r\n\r\n// JSON FUNCTIONS\r\nexport namespace json {\r\n  export function application<T>(): IJsonApplication; // JSON schema\r\n  export function assertParse<T>(input: string): T; // type safe parser\r\n  export function assertStringify<T>(input: T): string; // safe and faster\r\n}\r\n\r\n// PROTOCOL BUFFER\r\nexport namespace protobuf {\r\n  export function message<T>(): string; // Protocol Buffer message\r\n  export function assertDecode<T>(buffer: Uint8Array): T; // safe decoder\r\n  export function assertEncode<T>(input: T): Uint8Array; // safe encoder\r\n}\r\n\r\n// RANDOM GENERATOR\r\nexport function random<T>(g?: Partial<IRandomGenerator>): T;\nTypia is a transformer library supporting below features:\nSuper-fast Runtime Validators\nEnhanced JSON functions\nProtocol Buffer encoder and decoder\nRandom data generator\nOnly one line required, with pure TypeScript type\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer","sponsors#Sponsors":"Thanks for your support.Your donation would encourage typia development."}},"/docs/misc":{"title":"Misc","data":{"misc-module#misc module":"","clone-functions#clone() functions":"export namespace misc {\r\n  export function clone<T>(input: T): T;\r\n  export function assertClone<T>(input: T | unknown): Resolved<T>;\r\n  export function isClone<T>(input: T | unknown): Resolved<T> | null;\r\n  export function validateClone<T>(input: T | unknown): IValidation<Resolved<T>>;\r\n\r\n  export function createClone<T>(): (input: T) => Resolved<T>;\r\n  export function createAssertClone<T>(): (input: T | unknown) => Resolved<T>;\r\n  export function createIsClone<T>(): (input: T | unknown) => Resolved<T> | null;\r\n  export function createValidateClone<T>(): (\r\n      input: T | unknown\r\n  ) => IValidation<Resolved<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nDeep copy functions.When you want to copy an instance, just call typia.misc.clone() function. It would perform deep copy including nested objects, so you can get a new instance with same values. Also, if you want type safe deep copy function, you can use typia.misc.isClone(), typia.misc.assertClone() or typia.misc.validateClone() functions instead.\ntypia.misc.assertClone(): typia.assert<T>() + typia.misc.clone<T>()\ntypia.misc.isClone(): typia.is<T>() + typia.misc.clone<T>()\ntypia.misc.validateClone(): typia.validate<T>() + typia.misc.clone<T>()\nimport typia from \"typia\";\r\n\r\nconst department: IDepartment = typia.misc.random<IDepartment>();\r\nconst cloned: IDepartment = typia.misc.assertClone(department);\r\n\r\nconsole.log(cloned);\r\n\r\ninterface IDepartment {\r\n  /**\r\n   * @format uuid\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * @minLength 3\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * @type int\r\n   */\r\n  limit: number;\r\n\r\n  clerks: IClerk[];\r\n}\r\ninterface IClerk {\r\n  name: string;\r\n\r\n  /**\r\n   * @exclusiveMinimum 19\r\n   * @maximum 100\r\n   */\r\n  age: number;\r\n\r\n  authority: number;\r\n\r\n  /**\r\n   * @format date\r\n   */\r\n  joined_at: string;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst department = typia_1.default.misc.random();\r\nconst cloned = ((input) => {\r\n  const assert = (input) => {\r\n    const __is = (input) => {\r\n      const $io0 = (input) =>\r\n        \"string\" === typeof input.id &&\r\n        /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n          input.id,\r\n        ) &&\r\n        \"string\" === typeof input.name &&\r\n        3 <= input.name.length &&\r\n        \"number\" === typeof input.limit &&\r\n        Math.floor(input.limit) === input.limit &&\r\n        -2147483648 <= input.limit &&\r\n        input.limit <= 2147483647 &&\r\n        Array.isArray(input.clerks) &&\r\n        input.clerks.every(\r\n          (elem) => \"object\" === typeof elem && null !== elem && $io1(elem),\r\n        );\r\n      const $io1 = (input) =>\r\n        \"string\" === typeof input.name &&\r\n        \"number\" === typeof input.age &&\r\n        19 < input.age &&\r\n        input.age <= 100 &&\r\n        \"number\" === typeof input.authority &&\r\n        \"string\" === typeof input.joined_at &&\r\n        /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n      return \"object\" === typeof input && null !== input && $io0(input);\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.misc.assertClone.guard;\r\n        const $ao0 = (input, _path, _exceptionable = true) =>\r\n          ((\"string\" === typeof input.id &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input.id,\r\n            ) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".id\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input.id,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: '(string & Format<\"uuid\">)',\r\n              value: input.id,\r\n            })) &&\r\n          ((\"string\" === typeof input.name &&\r\n            (3 <= input.name.length ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".name\",\r\n                expected: \"string & MinLength<3>\",\r\n                value: input.name,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: \"(string & MinLength<3>)\",\r\n              value: input.name,\r\n            })) &&\r\n          ((\"number\" === typeof input.limit &&\r\n            ((Math.floor(input.limit) === input.limit &&\r\n              -2147483648 <= input.limit &&\r\n              input.limit <= 2147483647) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".limit\",\r\n                expected: 'number & Type<\"int32\">',\r\n                value: input.limit,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".limit\",\r\n              expected: '(number & Type<\"int32\">)',\r\n              value: input.limit,\r\n            })) &&\r\n          (((Array.isArray(input.clerks) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".clerks\",\r\n              expected: \"Array<IClerk>\",\r\n              value: input.clerks,\r\n            })) &&\r\n            input.clerks.every(\r\n              (elem, _index1) =>\r\n                (((\"object\" === typeof elem && null !== elem) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".clerks[\" + _index1 + \"]\",\r\n                    expected: \"IClerk\",\r\n                    value: elem,\r\n                  })) &&\r\n                  $ao1(\r\n                    elem,\r\n                    _path + \".clerks[\" + _index1 + \"]\",\r\n                    true && _exceptionable,\r\n                  )) ||\r\n                $guard(_exceptionable, {\r\n                  path: _path + \".clerks[\" + _index1 + \"]\",\r\n                  expected: \"IClerk\",\r\n                  value: elem,\r\n                }),\r\n            )) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".clerks\",\r\n              expected: \"Array<IClerk>\",\r\n              value: input.clerks,\r\n            }));\r\n        const $ao1 = (input, _path, _exceptionable = true) =>\r\n          (\"string\" === typeof input.name ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: \"string\",\r\n              value: input.name,\r\n            })) &&\r\n          ((\"number\" === typeof input.age &&\r\n            (19 < input.age ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & ExclusiveMinimum<19>\",\r\n                value: input.age,\r\n              })) &&\r\n            (input.age <= 100 ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & Maximum<100>\",\r\n                value: input.age,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"(number & ExclusiveMinimum<19> & Maximum<100>)\",\r\n              value: input.age,\r\n            })) &&\r\n          (\"number\" === typeof input.authority ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".authority\",\r\n              expected: \"number\",\r\n              value: input.authority,\r\n            })) &&\r\n          ((\"string\" === typeof input.joined_at &&\r\n            (/^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".joined_at\",\r\n                expected: 'string & Format<\"date\">',\r\n                value: input.joined_at,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".joined_at\",\r\n              expected: '(string & Format<\"date\">)',\r\n              value: input.joined_at,\r\n            }));\r\n        return (\r\n          (((\"object\" === typeof input && null !== input) ||\r\n            $guard(true, {\r\n              path: _path + \"\",\r\n              expected: \"IDepartment\",\r\n              value: input,\r\n            })) &&\r\n            $ao0(input, _path + \"\", true)) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IDepartment\",\r\n            value: input,\r\n          })\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  };\r\n  const clone = (input) => {\r\n    const $io1 = (input) =>\r\n      \"string\" === typeof input.name &&\r\n      \"number\" === typeof input.age &&\r\n      19 < input.age &&\r\n      input.age <= 100 &&\r\n      \"number\" === typeof input.authority &&\r\n      \"string\" === typeof input.joined_at &&\r\n      /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n    const $cp0 = (input) =>\r\n      input.map((elem) =>\r\n        \"object\" === typeof elem && null !== elem ? $co1(elem) : elem,\r\n      );\r\n    const $co0 = (input) => ({\r\n      id: input.id,\r\n      name: input.name,\r\n      limit: input.limit,\r\n      clerks: Array.isArray(input.clerks) ? $cp0(input.clerks) : input.clerks,\r\n    });\r\n    const $co1 = (input) => ({\r\n      name: input.name,\r\n      age: input.age,\r\n      authority: input.authority,\r\n      joined_at: input.joined_at,\r\n    });\r\n    return \"object\" === typeof input && null !== input ? $co0(input) : input;\r\n  };\r\n  assert(input);\r\n  const output = clone(input);\r\n  return output;\r\n})(department);\r\nconsole.log(cloned);","prune-functions#prune() functions":"export function prune<T>(input: T): void;\r\nexport function assertPrune<T>(input: T | unknown): T;\r\nexport function isPrune<T>(input: T | unknown): T | null;\r\nexport function validatePrune<T>(input: T | unknown): IValidation<T>;\r\n\r\nexport function createPrune<T>(): (input: T) => void;\r\nexport function createAssertPrune<T>(): (input: T | unknown) => T;\r\nexport function createIsPrune<T>(): (input: T | unknown) => T | null;\r\nexport function createValidatePrune<T>(): (input: T | unknown) => IValidation<T>;\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T = unknown> =\r\n  | IValidation.ISuccess<T>\r\n  | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T = unknown> {\r\n    success: true;\r\n    data: T;\r\n    errors: [];\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nDeep prune functions.When you want to remove every extra properties that are not defined in the type including nested objects, you can use typia.misc.prune<T>() function. Also, if you want to perform type safe pruning, you can use typia.misc.isPrune<T>(), typia.misc.assertPrune<T>() or typia.misc.validatePrune<T>() functions instead.\ntypia.misc.isPrune(): typia.is<T>() + typia.misc.prune<T>()\ntypia.misc.assertPrune(): typia.assert<T>() + typia.misc.prune<T>()\ntypia.misc.validatePrune(): typia.validate<T>() + typia.misc.prune<T>()\nimport typia from \"typia\";\r\n\r\nconst department: IDepartment = typia.misc.random<IDepartment>();\r\nconst pruned: IDepartment = typia.misc.assertPrune(department);\r\nconsole.log(pruned);\r\n\r\ninterface IDepartment {\r\n    /**\r\n     * @format uuid\r\n     */\r\n    id: string;\r\n\r\n    /**\r\n     * @minLength 3\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * @type int\r\n     */\r\n    limit: number;\r\n\r\n    clerks: IClerk[];\r\n}\r\ninterface IClerk {\r\n    name: string;\r\n\r\n    /**\r\n     * @exclusiveMinimum 19\r\n     * @maximum 100\r\n     */\r\n    age: number;\r\n\r\n    authority: number;\r\n\r\n    /**\r\n     * @format date\r\n     */\r\n    joined_at: string;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst department = typia_1.default.misc.random();\r\nconst pruned = ((input) => {\r\n  const assert = (input) => {\r\n    const __is = (input) => {\r\n      const $io0 = (input) =>\r\n        \"string\" === typeof input.id &&\r\n        /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n          input.id,\r\n        ) &&\r\n        \"string\" === typeof input.name &&\r\n        3 <= input.name.length &&\r\n        \"number\" === typeof input.limit &&\r\n        Math.floor(input.limit) === input.limit &&\r\n        -2147483648 <= input.limit &&\r\n        input.limit <= 2147483647 &&\r\n        Array.isArray(input.clerks) &&\r\n        input.clerks.every(\r\n          (elem) => \"object\" === typeof elem && null !== elem && $io1(elem),\r\n        );\r\n      const $io1 = (input) =>\r\n        \"string\" === typeof input.name &&\r\n        \"number\" === typeof input.age &&\r\n        19 < input.age &&\r\n        input.age <= 100 &&\r\n        \"number\" === typeof input.authority &&\r\n        \"string\" === typeof input.joined_at &&\r\n        /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n      return \"object\" === typeof input && null !== input && $io0(input);\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.misc.assertPrune.guard;\r\n        const $ao0 = (input, _path, _exceptionable = true) =>\r\n          ((\"string\" === typeof input.id &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input.id,\r\n            ) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".id\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input.id,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: '(string & Format<\"uuid\">)',\r\n              value: input.id,\r\n            })) &&\r\n          ((\"string\" === typeof input.name &&\r\n            (3 <= input.name.length ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".name\",\r\n                expected: \"string & MinLength<3>\",\r\n                value: input.name,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: \"(string & MinLength<3>)\",\r\n              value: input.name,\r\n            })) &&\r\n          ((\"number\" === typeof input.limit &&\r\n            ((Math.floor(input.limit) === input.limit &&\r\n              -2147483648 <= input.limit &&\r\n              input.limit <= 2147483647) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".limit\",\r\n                expected: 'number & Type<\"int32\">',\r\n                value: input.limit,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".limit\",\r\n              expected: '(number & Type<\"int32\">)',\r\n              value: input.limit,\r\n            })) &&\r\n          (((Array.isArray(input.clerks) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".clerks\",\r\n              expected: \"Array<IClerk>\",\r\n              value: input.clerks,\r\n            })) &&\r\n            input.clerks.every(\r\n              (elem, _index1) =>\r\n                (((\"object\" === typeof elem && null !== elem) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".clerks[\" + _index1 + \"]\",\r\n                    expected: \"IClerk\",\r\n                    value: elem,\r\n                  })) &&\r\n                  $ao1(\r\n                    elem,\r\n                    _path + \".clerks[\" + _index1 + \"]\",\r\n                    true && _exceptionable,\r\n                  )) ||\r\n                $guard(_exceptionable, {\r\n                  path: _path + \".clerks[\" + _index1 + \"]\",\r\n                  expected: \"IClerk\",\r\n                  value: elem,\r\n                }),\r\n            )) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".clerks\",\r\n              expected: \"Array<IClerk>\",\r\n              value: input.clerks,\r\n            }));\r\n        const $ao1 = (input, _path, _exceptionable = true) =>\r\n          (\"string\" === typeof input.name ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: \"string\",\r\n              value: input.name,\r\n            })) &&\r\n          ((\"number\" === typeof input.age &&\r\n            (19 < input.age ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & ExclusiveMinimum<19>\",\r\n                value: input.age,\r\n              })) &&\r\n            (input.age <= 100 ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & Maximum<100>\",\r\n                value: input.age,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"(number & ExclusiveMinimum<19> & Maximum<100>)\",\r\n              value: input.age,\r\n            })) &&\r\n          (\"number\" === typeof input.authority ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".authority\",\r\n              expected: \"number\",\r\n              value: input.authority,\r\n            })) &&\r\n          ((\"string\" === typeof input.joined_at &&\r\n            (/^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".joined_at\",\r\n                expected: 'string & Format<\"date\">',\r\n                value: input.joined_at,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".joined_at\",\r\n              expected: '(string & Format<\"date\">)',\r\n              value: input.joined_at,\r\n            }));\r\n        return (\r\n          (((\"object\" === typeof input && null !== input) ||\r\n            $guard(true, {\r\n              path: _path + \"\",\r\n              expected: \"IDepartment\",\r\n              value: input,\r\n            })) &&\r\n            $ao0(input, _path + \"\", true)) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IDepartment\",\r\n            value: input,\r\n          })\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  };\r\n  const prune = (input) => {\r\n    const $io1 = (input) =>\r\n      \"string\" === typeof input.name &&\r\n      \"number\" === typeof input.age &&\r\n      19 < input.age &&\r\n      input.age <= 100 &&\r\n      \"number\" === typeof input.authority &&\r\n      \"string\" === typeof input.joined_at &&\r\n      /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n    const $pp0 = (input) =>\r\n      input.forEach((elem) => {\r\n        if (\"object\" === typeof elem && null !== elem) $po1(elem);\r\n      });\r\n    const $po0 = (input) => {\r\n      if (Array.isArray(input.clerks)) $pp0(input.clerks);\r\n      for (const key of Object.keys(input)) {\r\n        if (\r\n          \"id\" === key ||\r\n          \"name\" === key ||\r\n          \"limit\" === key ||\r\n          \"clerks\" === key\r\n        )\r\n          continue;\r\n        delete input[key];\r\n      }\r\n    };\r\n    const $po1 = (input) => {\r\n      for (const key of Object.keys(input)) {\r\n        if (\r\n          \"name\" === key ||\r\n          \"age\" === key ||\r\n          \"authority\" === key ||\r\n          \"joined_at\" === key\r\n        )\r\n          continue;\r\n        delete input[key];\r\n      }\r\n    };\r\n    if (\"object\" === typeof input && null !== input) $po0(input);\r\n  };\r\n  assert(input);\r\n  prune(input);\r\n  return input;\r\n})(department);\r\nconsole.log(pruned);","literals-function#literals() function":"export namespace misc {\r\n  export function literals<\r\n    T extends boolean | number | string | bigint | null,\r\n  >(): T[];\r\n}\nUnion literal type to array.When you call typia.misc.literals<T>() function with union literal type, it returns an array of literal values listed in the generic T argument. This typia.misc.literals<T> function is useful when you are developing test program, especially handling some discriminated union types.\nimport typia from \"typia\";\r\n\r\ntypia.misc.literals<\"A\" | \"B\" | \"C\" | 1 | 2n>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n[\"A\", \"B\", \"C\", 1, BigInt(2)];","notations-module#notations module":"","camel-functions#camel() functions":"export namespace notations {\r\n  export function camel<T>(input: T): CamelCase<T>;\r\n  export function assertCamel<T>(input: T | unknown): CamelCase<T>;\r\n  export function isCamel<T>(input: T | unknown): CamelCase<T> | null;\r\n  export function validateCamel<T>(\r\n    input: T | unknown,\r\n  ): IValidation<CamelCase<T>>;\r\n\r\n  export function createCamel<T>(): (input: T) => CamelCase<T>;\r\n  export function createAssertCamel<T>(): (input: T | unknown) => CamelCase<T>;\r\n  export function createIsCamel<T>(): (\r\n    input: T | unknown,\r\n  ) => CamelCase<T> | null;\r\n  export function createValidateCamel<T>(): (\r\n    input: T | unknown,\r\n  ) => IValidation<CamelCase<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Camel case type.\r\n *\r\n * `CamelCase` type is a type that all keys of an object are camelized.\r\n *\r\n * It also erase every method properties like {@link Resolved} type.\r\n *\r\n * @template T Target type to be camelized\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type CamelCase<T> = Equal<T, CamelizeMain<T>> extends true\r\n  ? T\r\n  : CamelizeMain<T>;\r\n\r\n/* -----------------------------------------------------------\r\n    OBJECT CONVERSION\r\n----------------------------------------------------------- */\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype CamelizeMain<T> = T extends [never]\r\n  ? never // special trick for (jsonable | null) type\r\n  : T extends { valueOf(): boolean | bigint | number | string }\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? CamelizeObject<T>\r\n  : T;\r\n\r\ntype CamelizeObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? CamelizeTuple<T>\r\n    : CamelizeMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<CamelizeMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<CamelizeMain<K>, CamelizeMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [Key in keyof T as CamelizeString<Key & string>]: CamelizeMain<T[Key]>;\r\n    };\r\n\r\n/* -----------------------------------------------------------\r\n    SPECIAL CASES\r\n----------------------------------------------------------- */\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\ntype CamelizeTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [CamelizeMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [CamelizeMain<F>, ...CamelizeTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [CamelizeMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [CamelizeMain<F>?, ...CamelizeTuple<Rest>]\r\n  : [];\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n    STRING CONVERTER\r\n----------------------------------------------------------- */\r\ntype CamelizeString<Key extends string> = Key extends `_${infer R}`\r\n  ? `_${CamelizeString<R>}`\r\n  : Key extends `${infer F}${infer R}`\r\n  ? `${Lowercase<F>}${CamelizeStringRepeatedly<R>}`\r\n  : Key;\r\ntype CamelizeStringRepeatedly<Key extends string> =\r\n  Key extends `${infer F}_${infer R}`\r\n    ? `${F}${Capitalize<CamelizeStringRepeatedly<R>>}`\r\n    : Key;\nCamel case converters.Convert every property names of nested objects to be camel case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertCamel<T>(): typia.assert<T>() + typia.notations.camel<T>()\ntypia.notations.isCamel<T>: typia.is<T>() + typia.notations.camel<T>()\ntypia.notations.validateCamel<T>: typia.validate<T>() + typia.notations.camel<T>()\nimport typia from \"typia\";\r\n\r\ninterface IPerson {\r\n  is_my_name_samchon?: boolean;\r\n  HelloTheNewWorld: string;\r\n  ToHTML: string;\r\n}\r\ntypia.notations.createCamel<IPerson>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  const $co0 = (input) => ({\r\n    isMyNameSamchon: input.is_my_name_samchon,\r\n    helloTheNewWorld: input.HelloTheNewWorld,\r\n    toHTML: input.ToHTML,\r\n  });\r\n  return \"object\" === typeof input && null !== input ? $co0(input) : input;\r\n};","pascal-functions#pascal() functions":"export namespace notations {\r\n  export function pascal<T>(input: T): PascalCase<T>;\r\n  export function assertPascal<T>(input: T | unknown): PascalCase<T>;\r\n  export function isPascal<T>(input: T | unknown): PascalCase<T> | null;\r\n  export function validatePascal<T>(\r\n    input: T | unknown,\r\n  ): IValidation<PascalCase<T>>;\r\n\r\n  export function createPascal<T>(): (input: T) => PascalCase<T>;\r\n  export function createAssertPascal<T>(): (\r\n    input: T | unknown,\r\n  ) => PascalCase<T>;\r\n  export function createIsPascal<T>(): (\r\n    input: T | unknown,\r\n  ) => PascalCase<T> | null;\r\n  export function createValidatePascal<T>(): (\r\n    input: T | unknown,\r\n  ) => IValidation<PascalCase<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Pascal case type.\r\n *\r\n * `PascalCase` type is a type that all keys of an object are pascalized.\r\n *\r\n * It also erase every method properties like {@link Resolved} type.\r\n *\r\n * @template T Target type to be pascalized\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type PascalCase<T> = Equal<T, PascalizeMain<T>> extends true\r\n  ? T\r\n  : PascalizeMain<T>;\r\n\r\n/* -----------------------------------------------------------\r\n    OBJECT CONVERSION\r\n----------------------------------------------------------- */\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype PascalizeMain<T> = T extends [never]\r\n  ? never // special trick for (jsonable | null) type\r\n  : T extends { valueOf(): boolean | bigint | number | string }\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? PascalizeObject<T>\r\n  : T;\r\n\r\ntype PascalizeObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? PascalizeTuple<T>\r\n    : PascalizeMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<PascalizeMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<PascalizeMain<K>, PascalizeMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [Key in keyof T as PascalizeString<Key & string>]: PascalizeMain<T[Key]>;\r\n    };\r\n\r\n/* -----------------------------------------------------------\r\n    SPECIAL CASES\r\n----------------------------------------------------------- */\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\ntype PascalizeTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [PascalizeMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [PascalizeMain<F>, ...PascalizeTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [PascalizeMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [PascalizeMain<F>?, ...PascalizeTuple<Rest>]\r\n  : [];\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n    STRING CONVERTER\r\n----------------------------------------------------------- */\r\ntype PascalizeString<Key extends string> = Key extends `_${infer R}`\r\n  ? `_${PascalizeString<R>}`\r\n  : Key extends `${infer F}${infer R}`\r\n  ? `${Uppercase<F>}${PascalizeStringRepeatedly<R>}`\r\n  : Key;\r\ntype PascalizeStringRepeatedly<Key extends string> =\r\n  Key extends `${infer F}_${infer R}`\r\n    ? `${F}${Capitalize<PascalizeStringRepeatedly<R>>}`\r\n    : Key;\nPascal case converters.Convert every property names of nested objects to be pascal case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertPascal<T>(): typia.assert<T>() + typia.notations.pascal<T>()\ntypia.notations.isPascal<T>: typia.is<T>() + typia.notations.pascal<T>()\ntypia.notations.validatePascal<T>: typia.validate<T>() + typia.notations.pascal<T>()\nimport typia from \"typia\";\r\n\r\ninterface IPerson {\r\n  is_my_name_samchon?: boolean;\r\n  helloTheNewWorld: string;\r\n  toHTML: string;\r\n}\r\ntypia.notations.createPascal<IPerson>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  const $co0 = (input) => ({\r\n    IsMyNameSamchon: input.is_my_name_samchon,\r\n    HelloTheNewWorld: input.helloTheNewWorld,\r\n    ToHTML: input.toHTML,\r\n  });\r\n  return \"object\" === typeof input && null !== input ? $co0(input) : input;\r\n};","snake-functions#snake() functions":"export namespace notations {\r\n  export function snake<T>(input: T): SnakeCase<T>;\r\n  export function assertSnake<T>(input: T | unknown): SnakeCase<T>;\r\n  export function isSnake<T>(input: T | unknown): SnakeCase<T> | null;\r\n  export function validateSnake<T>(\r\n    input: T | unknown,\r\n  ): IValidation<SnakeCase<T>>;\r\n\r\n  export function createSnake<T>(): (input: T) => SnakeCase<T>;\r\n  export function createAssertSnake<T>(): (input: T | unknown) => SnakeCase<T>;\r\n  export function createIsSnake<T>(): (\r\n    input: T | unknown,\r\n  ) => SnakeCase<T> | null;\r\n  export function createValidateSnake<T>(): (\r\n    input: T | unknown,\r\n  ) => IValidation<SnakeCase<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Snake case type.\r\n *\r\n * `SnakeCase` type is a type that all keys of an object are converted to snake case.\r\n *\r\n * It also erase every method properties like {@link Resolved} type.\r\n *\r\n * @template T Target type to be snake cased\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type SnakeCase<T> = Equal<T, SnakageMain<T>> extends true\r\n  ? T\r\n  : SnakageMain<T>;\r\n\r\n/* -----------------------------------------------------------\r\n    OBJECT CONVERSION\r\n----------------------------------------------------------- */\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype SnakageMain<T> = T extends [never]\r\n  ? never // special trick for (jsonable | null) type\r\n  : T extends { valueOf(): boolean | bigint | number | string }\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? SnakageObject<T>\r\n  : T;\r\n\r\ntype SnakageObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? SnakageTuple<T>\r\n    : SnakageMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<SnakageMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<SnakageMain<K>, SnakageMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [Key in keyof T as SnakageString<Key & string>]: SnakageMain<T[Key]>;\r\n    };\r\n\r\n/* -----------------------------------------------------------\r\n    SPECIAL CASES\r\n----------------------------------------------------------- */\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\ntype SnakageTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [SnakageMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [SnakageMain<F>, ...SnakageTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [SnakageMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [SnakageMain<F>?, ...SnakageTuple<Rest>]\r\n  : [];\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n    STRING CONVERTER\r\n----------------------------------------------------------- */\r\ntype SnakageString<Key extends string> = Key extends `${infer _}`\r\n  ? SnakageStringRepeatedly<Key, \"\">\r\n  : Key;\r\ntype SnakageStringRepeatedly<\r\n  S extends string,\r\n  Previous extends string,\r\n> = S extends `${infer First}${infer Second}${infer Rest}`\r\n  ? `${Underscore<Previous, First>}${Lowercase<First>}${Underscore<\r\n      First,\r\n      Second\r\n    >}${Lowercase<Second>}${SnakageStringRepeatedly<Rest, Second>}`\r\n  : S extends `${infer First}`\r\n  ? `${Underscore<Previous, First>}${Lowercase<First>}`\r\n  : \"\";\r\ntype Underscore<First extends string, Second extends string> = First extends\r\n  | UpperAlphabetic\r\n  | \"\"\r\n  | \"_\"\r\n  ? \"\"\r\n  : Second extends UpperAlphabetic\r\n  ? \"_\"\r\n  : \"\";\r\ntype UpperAlphabetic =\r\n  | \"A\"\r\n  | \"B\"\r\n  | \"C\"\r\n  | \"D\"\r\n  | \"E\"\r\n  | \"F\"\r\n  | \"G\"\r\n  | \"H\"\r\n  | \"I\"\r\n  | \"J\"\r\n  | \"K\"\r\n  | \"L\"\r\n  | \"M\"\r\n  | \"N\"\r\n  | \"O\"\r\n  | \"P\"\r\n  | \"Q\"\r\n  | \"R\"\r\n  | \"S\"\r\n  | \"T\"\r\n  | \"U\"\r\n  | \"V\"\r\n  | \"W\"\r\n  | \"X\"\r\n  | \"Y\"\r\n  | \"Z\";\nSnake case converters.Convert every property names of nested objects to be snake case notation.When you need type safe functions, you can utilize below them.\ntypia.notations.assertSnake<T>(): typia.assert<T>() + typia.notations.snake<T>()\ntypia.notations.isSnake<T>: typia.is<T>() + typia.notations.snake<T>()\ntypia.notations.validateSnake<T>: typia.validate<T>() + typia.notations.snake<T>()\nimport typia from \"typia\";\r\n\r\ninterface IPerson {\r\n  isMyNameSamchon?: boolean;\r\n  HelloTheNewWorld: string;\r\n  ToHTML: string;\r\n}\r\ntypia.notations.createSnake<IPerson>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  const $co0 = (input) => ({\r\n    is_my_name_samchon: input.isMyNameSamchon,\r\n    hello_the_new_world: input.HelloTheNewWorld,\r\n    to_html: input.ToHTML,\r\n  });\r\n  return \"object\" === typeof input && null !== input ? $co0(input) : input;\r\n};","http-module#http module":"Nestia Supporting\nhttp module has been designed to support the nestia project.\nquery() functions -> @TypedQuery()\nheaders() functions -> @TypedHeaders()\nparameter() function -> @TypedParam()","query-functions#query() functions":"export namespace http {\r\n  export function query<T extends object>(input: Query): Resolved<T>;\r\n  export function assertQuery<T extends object>(input: Query): Resolved<T>;\r\n  export function isQuery<T extends object>(input: Query): Resolved<T> | null;\r\n  export function validateQuery<T extends object>(\r\n    input: Query,\r\n  ): IValidation<Resolved<T>>;\r\n\r\n  export function createQuery<T extends object>(): (\r\n    input: Query,\r\n  ) => Resolved<T>;\r\n  export function createAssertQuery<T extends object>(): (\r\n    input: Query,\r\n  ) => Resolved<T>;\r\n  export function createIsQuery<T extends object>(): (\r\n    input: Query,\r\n  ) => Resolved<T> | null;\r\n  export function createValidateQuery<T extends object>(): (\r\n    input: Query,\r\n  ) => IValidation<Resolved<T>>;\r\n}\r\ntype Query = string | URLSearchParams;\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nURL query decoder functions.typia.http.query<T>() is a function decoding a query string or an URLSearchParams instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, typia.http.query<T>() will cast the value to the expected type when decoding.By the way, as URL query is not enough to express complex data structures, typia.http.query<T>() function has some limitations. If target type T is not following those restrictions, compilation errors would be occured.\nType T must be an object type\nDo not allow dynamic property\nOnly boolean, bigint, number, string or their array types are allowed\nBy the way, union type never be not allowed\nAlso, typia.http.query<T>() function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the T type, it would better to call one of below functions intead.\ntypia.http.assertQuery<T>(): typia.assert<T>() + typia.http.query<T>()\ntypia.http.isQuery<T>(): typia.is<T>() + typia.http.query<T>()\ntypia.http.validateQuery<T>(): typia.validate<T>() + typia.http.query<T>()\nimport typia from \"typia\";\r\n\r\ninterface IQuery {\r\n  limit?: number;\r\n  enforce: boolean;\r\n  values?: string[];\r\n  atomic: string | null;\r\n  indexes: number[];\r\n}\r\ntypia.http.createQuery<IQuery>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  const $params = typia_1.default.http.createQuery.params;\r\n  const $number = typia_1.default.http.createQuery.number;\r\n  const $boolean = typia_1.default.http.createQuery.boolean;\r\n  const $string = typia_1.default.http.createQuery.string;\r\n  const $array = typia_1.default.http.createQuery.array;\r\n  input = $params(input);\r\n  const output = {\r\n    limit: $number(input.get(\"limit\")) ?? undefined,\r\n    enforce: $boolean(input.get(\"enforce\")),\r\n    values: $array(\r\n      input.getAll(\"values\").map((elem) => $string(elem)),\r\n      undefined,\r\n    ),\r\n    atomic: $string(input.get(\"atomic\")),\r\n    indexes: input.getAll(\"indexes\").map((elem) => $number(elem)),\r\n  };\r\n  return output;\r\n};","headers-functions#headers() functions":"export namespace http {\r\n  export function headers<T extends object>(input: Headers): Resolved<T>;\r\n  export function assertHeaders<T extends object>(input: Headers): Resolved<T>;\r\n  export function isHeaders<T extends object>(\r\n    input: Headers,\r\n  ): Resolved<T> | null;\r\n  export function validateHeaders<T extends object>(\r\n    input: Headers,\r\n  ): IValidation<Resolved<T>>;\r\n\r\n  export function createHeaders<T extends object>(): (\r\n    input: Headers,\r\n  ) => Resolved<T>;\r\n  export function createAssertHeaders<T extends object>(): (\r\n    input: Headers,\r\n  ) => Resolved<T>;\r\n  export function createIsHeaders<T extends object>(): (\r\n    input: Headers,\r\n  ) => Resolved<T> | null;\r\n  export function createValidateHeaders<T extends object>(): (\r\n    input: Headers,\r\n  ) => IValidation<Resolved<T>>;\r\n}\r\ntype Headers = Record<string, string | string[] | undefined>;\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nHeaders decoder (for express and fastify).typia.http.headers<t>() is a function decoding an header instance, with automatic type casting to the expected type. When property type be defined as boolean or number type, typia.http.headers<t>() will cast the value to the expected type.By the way, as HTTP headers are not enough to express complex data structures, typia.http.headers<t>() function has some limitations. If target type T is not following those restrictions, compilation errors would be occured.\nType T must be an object type\nDo not allow dynamic property\nProperty key must be lower case\nProperty value cannot be null, but undefined is possible\nOnly boolean, bigint, number, string or their array types are allowed\nBy the way, union type never be not allowed\nProperty set-cookie must be array type\nThose properties cannot be array type\nage\nauthorization\ncontent-length\ncontent-type\netag\nexpires\nfrom\nhost\nif-modified-since\nif-unmodified-since\nlast-modified\nlocation\nmax-forwards\nproxy-authorization\nreferer\nretry-after\nserver\nuser-agent\nAlso, typia.http.headers<t>() function does not perform validation about the decoded value. Therefore, if you can't sure that input data is following the T type, it would better to call one of below functions intead.\ntypia.http.assertHeaders<T>(): typia.assert<T>() + typia.http.headers<T>()\ntypia.http.isHeaders<T>(): typia.is<T>() + typia.http.headers<T>()\ntypia.http.validateHeaders<T>(): typia.validate<T>() + typia.http.headers<T>()\nimport typia from \"typia\";\r\n\r\ninterface IHeaders {\r\n  \"x-Category\": \"x\" | \"y\" | \"z\";\r\n  \"x-MEMO\"?: string;\r\n  \"x-nAmE\"?: string;\r\n  \"x-ValUes\": number[];\r\n  \"x-FlAgS\": boolean[];\r\n  \"X-Descriptions\": string[];\r\n}\r\ntypia.http.createHeaders<IHeaders>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  const $number = typia_1.default.http.createHeaders.number;\r\n  const $boolean = typia_1.default.http.createHeaders.boolean;\r\n  const $string = typia_1.default.http.createHeaders.string;\r\n  const output = {\r\n    \"x-Category\": input[\"x-category\"],\r\n    \"x-MEMO\": input[\"x-memo\"],\r\n    \"x-nAmE\": input[\"x-name\"],\r\n    \"x-ValUes\": Array.isArray(input[\"x-values\"])\r\n      ? input[\"x-values\"].map($number)\r\n      : input[\"x-values\"]?.split(\", \")?.map($number) ?? [],\r\n    \"x-FlAgS\": Array.isArray(input[\"x-flags\"])\r\n      ? input[\"x-flags\"].map($boolean)\r\n      : input[\"x-flags\"]?.split(\", \")?.map($boolean) ?? [],\r\n    \"X-Descriptions\": Array.isArray(input[\"x-descriptions\"])\r\n      ? input[\"x-descriptions\"].map($string)\r\n      : input[\"x-descriptions\"]?.split(\", \")?.map($string) ?? [],\r\n  };\r\n  return output;\r\n};","parameter-functions#parameter() functions":"export namespace http {\r\n  export function parameter<T extends Atomic.Type | null>(input: string): T;\r\n  export function createParameter<T extends Atomic.Type | null>(): (\r\n    input: string,\r\n  ) => T;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nURL path parameter decoder.typia.http.parameter<T>() is a function decoding a path parameter, with automatic type casting to the expected type. When type T has beeen defined as boolean or number type, typia.http.parameter<T>() will cast the value to the expected type.Also, typia.http.parameter<T>() performs type assertion to the decoded value by combining with assert function. Therefore, when the decoded value is not following the T type, TypeGuardError would be thrown.\nimport typia, { tags } from \"typia\";\r\n\r\ntypia.http.createParameter<string & tags.Format<\"uuid\">>();\r\ntypia.http.createParameter<number & tags.Type<\"uint32\">>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  const $string = typia_1.default.http.createParameter.string;\r\n  const assert = (input) => {\r\n    const __is = (input) => {\r\n      return (\r\n        \"string\" === typeof input &&\r\n        /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n          input,\r\n        )\r\n      );\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.http.createParameter.guard;\r\n        return (\r\n          (\"string\" === typeof input &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input,\r\n            ) ||\r\n              $guard(true, {\r\n                path: _path + \"\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input,\r\n              }))) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: '(string & Format<\"uuid\">)',\r\n            value: input,\r\n          })\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  };\r\n  const value = $string(input);\r\n  return assert(value);\r\n};\r\n(input) => {\r\n  const $number = typia_1.default.http.createParameter.number;\r\n  const assert = (input) => {\r\n    const __is = (input) => {\r\n      return (\r\n        \"number\" === typeof input &&\r\n        Math.floor(input) === input &&\r\n        0 <= input &&\r\n        input <= 4294967295\r\n      );\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.http.createParameter.guard;\r\n        return (\r\n          (\"number\" === typeof input &&\r\n            ((Math.floor(input) === input &&\r\n              0 <= input &&\r\n              input <= 4294967295) ||\r\n              $guard(true, {\r\n                path: _path + \"\",\r\n                expected: 'number & Type<\"uint32\">',\r\n                value: input,\r\n              }))) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: '(number & Type<\"uint32\">)',\r\n            value: input,\r\n          })\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  };\r\n  const value = $number(input);\r\n  return assert(value);\r\n};"}},"/docs/random":{"title":"Random","data":{"random-function#random() function":"export function random<T>(g?: IRandomGenerator): Resolved<T>;\nimport { Customizable } from \"./typings/Customizable\";\r\n\r\nexport interface IRandomGenerator {\r\n  // REGULAR\r\n  boolean(): boolean;\r\n  integer(minimum?: number, maximum?: number): number;\r\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\r\n  number(minimum?: number, maximum?: number): number;\r\n  string(length?: number): string;\r\n\r\n  array<T>(closure: (index: number) => T, count?: number): T[];\r\n  length(): number;\r\n  pattern(regex: RegExp): string;\r\n\r\n  //----\r\n  // FORMAT\r\n  //----\r\n  // SPECIAL CHARACTERS\r\n  byte(): string;\r\n  password(): string;\r\n  regex(): string;\r\n  uuid(): string;\r\n\r\n  // ADDRESSES\r\n  email(): string;\r\n  hostname(): string;\r\n  idnEmail(): string;\r\n  idnHostname(): string;\r\n  iri(): string;\r\n  iriReference(): string;\r\n  ipv4(): string;\r\n  ipv6(): string;\r\n  uri(): string;\r\n  uriReference(): string;\r\n  uriTemplate(): string;\r\n  url(): string;\r\n\r\n  // TIMESTAMPS\r\n  datetime(minimum?: number, maximum?: number): string;\r\n  date(minimum?: number, maximum?: number): string;\r\n  time(): string;\r\n  duration(): string;\r\n\r\n  // POINTERS\r\n  jsonPointer(): string;\r\n  relativeJsonPointer(): string;\r\n\r\n  customs?: IRandomGenerator.CustomMap;\r\n}\r\nexport namespace IRandomGenerator {\r\n  export type CustomMap = {\r\n    [Type in keyof Customizable]?: (\r\n      tags: ITypeTag[],\r\n    ) => Customizable[Type] | undefined;\r\n  };\r\n  export interface ITypeTag {\r\n    name: string;\r\n    kind: string;\r\n    value: any;\r\n  }\r\n}\nexport interface Customizable {\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nYou can make every random data just by calling typia.random<T>() function.When you call the typia.random<T>() function, typia will analyze your type T, and writes optimal random generation code for the type T, in the compilation level. This is called AOT (Ahead of Time) compliation, and you may understand what it is just by reading below example code.\nimport typia, { tags } from \"typia\";\r\n\r\nconst member: IMember = typia.random<IMember>();\r\nconsole.log(member);\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst member = ((generator) => {\r\n  const $generator = typia_1.default.random.generator;\r\n  const $ro0 = (_recursive = false, _depth = 0) => ({\r\n    id:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"uuid\">',\r\n          kind: \"format\",\r\n          value: \"uuid\",\r\n        },\r\n      ]) ?? (generator?.uuid ?? $generator.uuid)(),\r\n    email:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"email\">',\r\n          kind: \"format\",\r\n          value: \"email\",\r\n        },\r\n      ]) ?? (generator?.email ?? $generator.email)(),\r\n    age:\r\n      (generator?.customs ?? $generator.customs)?.number?.([\r\n        {\r\n          name: 'Type<\"uint32\">',\r\n          kind: \"type\",\r\n          value: \"uint32\",\r\n        },\r\n        {\r\n          name: \"ExclusiveMinimum<19>\",\r\n          kind: \"exclusiveMinimum\",\r\n          value: 19,\r\n        },\r\n        {\r\n          name: \"Maximum<100>\",\r\n          kind: \"maximum\",\r\n          value: 100,\r\n        },\r\n      ]) ?? (generator?.integer ?? $generator.integer)(19, 100),\r\n  });\r\n  return $ro0();\r\n})();\r\nconsole.log(member);","reusable-function#Reusable function":"export function createRandom<T>(): (g?: IRandomGenerator) => Resolved<T>;\nimport { Customizable } from \"./typings/Customizable\";\r\n\r\nexport interface IRandomGenerator {\r\n  // REGULAR\r\n  boolean(): boolean;\r\n  integer(minimum?: number, maximum?: number): number;\r\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\r\n  number(minimum?: number, maximum?: number): number;\r\n  string(length?: number): string;\r\n\r\n  array<T>(closure: (index: number) => T, count?: number): T[];\r\n  length(): number;\r\n  pattern(regex: RegExp): string;\r\n\r\n  //----\r\n  // FORMAT\r\n  //----\r\n  // SPECIAL CHARACTERS\r\n  byte(): string;\r\n  password(): string;\r\n  regex(): string;\r\n  uuid(): string;\r\n\r\n  // ADDRESSES\r\n  email(): string;\r\n  hostname(): string;\r\n  idnEmail(): string;\r\n  idnHostname(): string;\r\n  iri(): string;\r\n  iriReference(): string;\r\n  ipv4(): string;\r\n  ipv6(): string;\r\n  uri(): string;\r\n  uriReference(): string;\r\n  uriTemplate(): string;\r\n  url(): string;\r\n\r\n  // TIMESTAMPS\r\n  datetime(minimum?: number, maximum?: number): string;\r\n  date(minimum?: number, maximum?: number): string;\r\n  time(): string;\r\n  duration(): string;\r\n\r\n  // POINTERS\r\n  jsonPointer(): string;\r\n  relativeJsonPointer(): string;\r\n\r\n  customs?: IRandomGenerator.CustomMap;\r\n}\r\nexport namespace IRandomGenerator {\r\n  export type CustomMap = {\r\n    [Type in keyof Customizable]?: (\r\n      tags: ITypeTag[],\r\n    ) => Customizable[Type] | undefined;\r\n  };\r\n  export interface ITypeTag {\r\n    name: string;\r\n    kind: string;\r\n    value: any;\r\n  }\r\n}\nexport interface Customizable {\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}","special-tags#Special Tags":"Runtime validators of typia provides additional type checking logic through Type Tags and Comment Tags. typia.random<T>() function also like that. typia.random<T>() function can utilize those tags to specialize the behavior of random data generation.For reference, whether you choose Type Tags or Comment Tags. typia.random<T>(), it is not a matter for typia.random<T>() function. Below two TypeScript codes are generating exactly same JavaScript code. Therefore, you can choose whatever you want considering your preference.\nimport typia, { tags } from \"typia\";\r\n\r\nconst data: TypeTag = typia.random<TypeTag>();\r\n\r\nconsole.log(data);\r\n\r\ninterface TypeTag {\r\n  type: number & tags.Type<\"int32\">;\r\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  string: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  format: (string & tags.Format<\"date-time\">) | null;\r\n}\nimport typia from \"typia\";\r\n\r\nconst data: CommentTag = typia.random<CommentTag>();\r\n\r\nconsole.log(data);\r\n\r\ninterface CommentTag {\r\n  /**\r\n   * @type int\r\n   */\r\n  type: number;\r\n\r\n  /**\r\n   * @exclusiveMinimum 19\r\n   * @maximum 100\r\n   */\r\n  number?: number;\r\n\r\n  /**\r\n   * @minLength 3\r\n   */\r\n  string: string;\r\n\r\n  /**\r\n   * @pattern ^[a-z]+$\r\n   */\r\n  pattern: string;\r\n\r\n  /**\r\n   * @format date-time\r\n   */\r\n  format: string | null;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst data = ((generator) => {\r\n  const $generator = typia_1.default.random.generator;\r\n  const $pick = typia_1.default.random.pick;\r\n  const $ro0 = (_recursive = false, _depth = 0) => ({\r\n    type:\r\n      (generator?.customs ?? $generator.customs)?.number?.([\r\n        {\r\n          name: 'Type<\"int32\">',\r\n          kind: \"type\",\r\n          value: \"int32\",\r\n        },\r\n      ]) ?? (generator?.integer ?? $generator.integer)(0, 100),\r\n    number: $pick([\r\n      () => undefined,\r\n      () =>\r\n        (generator?.customs ?? $generator.customs)?.number?.([\r\n          {\r\n            name: \"ExclusiveMinimum<19>\",\r\n            kind: \"exclusiveMinimum\",\r\n            value: 19,\r\n          },\r\n          {\r\n            name: \"Maximum<100>\",\r\n            kind: \"maximum\",\r\n            value: 100,\r\n          },\r\n        ]) ?? (generator?.number ?? $generator.number)(19, 100),\r\n    ])(),\r\n    string:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: \"MinLength<3>\",\r\n          kind: \"minLength\",\r\n          value: 3,\r\n        },\r\n      ]) ??\r\n      (generator?.string ?? $generator.string)(\r\n        (generator?.integer ?? $generator.integer)(3, 25),\r\n      ),\r\n    pattern:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Pattern<\"^[a-z]+$\">',\r\n          kind: \"pattern\",\r\n          value: \"^[a-z]+$\",\r\n        },\r\n      ]) ?? (generator?.pattern ?? $generator.pattern)(/^[a-z]+$/),\r\n    format: $pick([\r\n      () => null,\r\n      () =>\r\n        (generator?.customs ?? $generator.customs)?.string?.([\r\n          {\r\n            name: 'Format<\"date-time\">',\r\n            kind: \"format\",\r\n            value: \"date-time\",\r\n          },\r\n        ]) ?? (generator?.datetime ?? $generator.datetime)(),\r\n    ])(),\r\n  });\r\n  return $ro0();\r\n})();\r\nconsole.log(data);","customization#Customization":"import { Customizable } from \"./typings/Customizable\";\r\n\r\nexport interface IRandomGenerator {\r\n  // REGULAR\r\n  boolean(): boolean;\r\n  integer(minimum?: number, maximum?: number): number;\r\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\r\n  number(minimum?: number, maximum?: number): number;\r\n  string(length?: number): string;\r\n\r\n  array<T>(closure: (index: number) => T, count?: number): T[];\r\n  length(): number;\r\n  pattern(regex: RegExp): string;\r\n\r\n  //----\r\n  // FORMAT\r\n  //----\r\n  // SPECIAL CHARACTERS\r\n  byte(): string;\r\n  password(): string;\r\n  regex(): string;\r\n  uuid(): string;\r\n\r\n  // ADDRESSES\r\n  email(): string;\r\n  hostname(): string;\r\n  idnEmail(): string;\r\n  idnHostname(): string;\r\n  iri(): string;\r\n  iriReference(): string;\r\n  ipv4(): string;\r\n  ipv6(): string;\r\n  uri(): string;\r\n  uriReference(): string;\r\n  uriTemplate(): string;\r\n  url(): string;\r\n\r\n  // TIMESTAMPS\r\n  datetime(minimum?: number, maximum?: number): string;\r\n  date(minimum?: number, maximum?: number): string;\r\n  time(): string;\r\n  duration(): string;\r\n\r\n  // POINTERS\r\n  jsonPointer(): string;\r\n  relativeJsonPointer(): string;\r\n\r\n  customs?: IRandomGenerator.CustomMap;\r\n}\r\nexport namespace IRandomGenerator {\r\n  export type CustomMap = {\r\n    [Type in keyof Customizable]?: (\r\n      tags: ITypeTag[],\r\n    ) => Customizable[Type] | undefined;\r\n  };\r\n\r\n  export interface ITypeTag {\r\n    name: string;\r\n    kind: string;\r\n    value: any;\r\n  }\r\n}\nexport interface Customizable {\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nYou can add custom type tags for random data generation.As above IRandomGenerator.CustomMap has a little bit complicate type, it may hard to understand for newcomers. However, such newcomers may easily understand, how to customize the random generation, just by reading the following example.Just define custom type tags like below, then everything would be done.For reference, when defining custom type tag, typia enforces user to define validate function literal for type safety. Never forget it when you define custom type tags for random generation. Such validation logic definition may enhance your random data generator logic when combining with typia.assert<T>() function.\nimport typia from \"typia\";\r\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\r\n\r\nconst data: TagCustom = typia.random<TagCustom>({\r\n  customs: {\r\n    string: (tags) => {\r\n      if (tags.find((t) => t.kind === \"dollar\") !== undefined)\r\n        return \"$\" + RandomGenerator.integer();\r\n      const postfix = tags.find((t) => t.kind === \"postfix\");\r\n      if (postfix !== undefined)\r\n        return RandomGenerator.string() + postfix.value;\r\n    },\r\n  },\r\n});\r\n\r\nconsole.log(data);\r\n\r\ninterface TagCustom {\r\n  id: string & typia.tags.Format<\"uuid\">;\r\n  dollar: string & Dolloar;\r\n  postfix: string & Postfix<\"abcd\">;\r\n  powerOf: number & PowerOf<2>;\r\n}\r\n\r\ntype Dolloar = typia.tags.TagBase<{\r\n  kind: \"dollar\";\r\n  target: \"string\";\r\n  value: undefined;\r\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\r\n}>;\r\n\r\ntype Postfix<Value extends string> = typia.tags.TagBase<{\r\n  kind: \"postfix\";\r\n  target: \"string\";\r\n  value: Value;\r\n  validate: `$input.endsWith(\"${Value}\")`;\r\n}>;\r\n\r\ntype PowerOf<Value extends number> = typia.tags.TagBase<{\r\n  kind: \"powerOf\";\r\n  target: \"number\";\r\n  value: Value;\r\n  validate: `(() => {\r\n        const denominator: number = Math.log(${Value});\r\n        const value: number = Math.log($input) / denominator;\r\n        return Math.abs(value - Math.round(value)) < 0.00000001;\r\n    })()`;\r\n}>;\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst RandomGenerator_1 = require(\"typia/lib/utils/RandomGenerator\");\r\nconst data = ((generator) => {\r\n  const $generator = typia_1.default.random.generator;\r\n  const $ro0 = (_recursive = false, _depth = 0) => ({\r\n    id:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"uuid\">',\r\n          kind: \"format\",\r\n          value: \"uuid\",\r\n        },\r\n      ]) ?? (generator?.uuid ?? $generator.uuid)(),\r\n    dollar:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: \"Dolloar\",\r\n          kind: \"dollar\",\r\n        },\r\n      ]) ?? (generator?.string ?? $generator.string)(),\r\n    postfix:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Postfix<\"abcd\">',\r\n          kind: \"postfix\",\r\n          value: \"abcd\",\r\n        },\r\n      ]) ?? (generator?.string ?? $generator.string)(),\r\n    powerOf:\r\n      (generator?.customs ?? $generator.customs)?.number?.([\r\n        {\r\n          name: \"PowerOf<2>\",\r\n          kind: \"powerOf\",\r\n          value: 2,\r\n        },\r\n      ]) ?? (generator?.number ?? $generator.number)(0, 100),\r\n  });\r\n  return $ro0();\r\n})({\r\n  customs: {\r\n    string: (tags) => {\r\n      if (tags.find((t) => t.kind === \"dollar\") !== undefined)\r\n        return \"$\" + RandomGenerator_1.RandomGenerator.integer();\r\n      const postfix = tags.find((t) => t.kind === \"postfix\");\r\n      if (postfix !== undefined)\r\n        return RandomGenerator_1.RandomGenerator.string() + postfix.value;\r\n    },\r\n  },\r\n});\r\nconsole.log(data);"}},"/docs/validators/functional":{"title":"Functional","data":{"assertfunction#assertFunction()":"export namespace functional {\r\n  export function assertFunction<T extends Function>(func: T): T;\r\n  export function assertParameters<T extends Function>(func: T): T;\r\n  export function assertReturn<T extends Function>(func: T): T;\r\n\r\n  export function assertEqualsFunction<T extends Function>(func: T): T;\r\n  export function assertEqualsParameters<T extends Function>(func: T): T;\r\n  export function assertEqualsReturn<T extends Function>(func: T): T;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nAsserts a function.typia.functional.assertFunction<T>() asserts a function, by wrapping the parameter function and checking its parametrs and return value through typia.assert<T>() function. If some parameter or return value does not match the expected type, it throws a TypeGuardError error.For reference, TypeGuardError.path would be a little bit different with individual typia.assert<T>() function. If TypeGuardError occurs from some parameter, the path wouold start from $input.parameters[<index>]. Otherwise the path would start from $input.return.\n$input.parameters[0].~\n$input.return.~\nBy the way, if you don't want to assert both paramters and return value, but one of them, you can use typia.functional.assertParameters<T>() or typia.functional.assertReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.assertEqualsFunction<T>() would be helpful.Also, if what you want is not just finding the first type error through assertion, but also finding every type errors, utilize typia.functional.validateFunction<T>() function instead. Otherwise, you don't need the reason why, but just want to know whether the function is valid or not, use typia.functional.isFunction<T>() function.\nimport typia from \"typia\";\r\n\r\ntypia.functional.assertFunction(\r\n  (x: number, y: number) => x + y,\r\n)(3, 4);\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n((x, y) => {\r\n  const errorFactoryWrapper =\r\n    typia_1.default.functional.assertFunction.errorFactory;\r\n  ((\r\n    input,\r\n    errorFactory = (p) =>\r\n      errorFactoryWrapper({\r\n        ...p,\r\n        path: p.path\r\n          ? p.path.replace(\"$input\", \"$input.parameters[0]\")\r\n          : undefined,\r\n      }),\r\n  ) => {\r\n    const __is = (input) => {\r\n      return \"number\" === typeof input;\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.functional.assertFunction.guard;\r\n        return (\r\n          \"number\" === typeof input ||\r\n          $guard(\r\n            true,\r\n            {\r\n              path: _path + \"\",\r\n              expected: \"number\",\r\n              value: input,\r\n            },\r\n            errorFactory,\r\n          )\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  })(x);\r\n  ((\r\n    input,\r\n    errorFactory = (p) =>\r\n      errorFactoryWrapper({\r\n        ...p,\r\n        path: p.path\r\n          ? p.path.replace(\"$input\", \"$input.parameters[1]\")\r\n          : undefined,\r\n      }),\r\n  ) => {\r\n    const __is = (input) => {\r\n      return \"number\" === typeof input;\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.functional.assertFunction.guard;\r\n        return (\r\n          \"number\" === typeof input ||\r\n          $guard(\r\n            true,\r\n            {\r\n              path: _path + \"\",\r\n              expected: \"number\",\r\n              value: input,\r\n            },\r\n            errorFactory,\r\n          )\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  })(y);\r\n  return ((\r\n    input,\r\n    errorFactory = (p) =>\r\n      errorFactoryWrapper({\r\n        ...p,\r\n        path: p.path ? p.path.replace(\"$input\", \"$input.return\") : undefined,\r\n      }),\r\n  ) => {\r\n    const __is = (input) => {\r\n      return true;\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        return true;\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  })(((x, y) => x + y)(x, y));\r\n})(3, 4);","isfunction#isFunction()":"export namespace functional {\r\n  export function isFunction<T extends (...args: any[]) => any>(\r\n    func: T,\r\n  ): T extends (...args: infer Arguments) => infer Output\r\n    ? Output extends Promise<infer R>\r\n      ? (...args: Arguments) => Promise<R | null>\r\n      : (...args: Arguments) => Output | null\r\n    : never;\r\n  export function isParameters;\r\n  export function isReturn;\r\n\r\n  export function isEqualsFunction;\r\n  export function isEqualsParameters;\r\n  export function isEqualsReturn;\r\n}\nTests a function.typia.functional.isFunction<T>() tests a function, by wrapping the parameter function and checking its paramters and return value through typia.is<T>() function. If some parameter or return value does not match the expected type, it returns null. Otherwise, it returns the return value of the parameter function.By the way, if you don't want to test both paramters and return value, but one of them, you can use typia.functional.isParameters<T>() or typia.functional.isReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.equalsFunction<T>() would be helpful.Also, if what you want is not just type checking, but want to know the detailed reason(s) why, utilize typia.functional.assertFunction<T>() or typia.functional.validateFunction<T>() instead.\nimport typia from \"typia\";\r\n\r\ntypia.functional.isFunction(\r\n  (x: number, y: number) => x + y,\r\n)(3, 4);\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n((x, y) => {\r\n  if (\r\n    false ===\r\n    ((input) => {\r\n      return \"number\" === typeof input;\r\n    })(x)\r\n  )\r\n    return null;\r\n  if (\r\n    false ===\r\n    ((input) => {\r\n      return \"number\" === typeof input;\r\n    })(y)\r\n  )\r\n    return null;\r\n  const result = ((x, y) => x + y)(x, y);\r\n  return ((input) => {\r\n    return true;\r\n  })(result)\r\n    ? result\r\n    : null;\r\n})(3, 4);","validatefunction#validateFunction()":"export namespace functional {\r\n  export function validateFunction<T extends (...args: any[]) => any>(\r\n    func: T,\r\n  ): T extends (...args: infer Arguments) => infer Output\r\n    ? Output extends Promise<infer R>\r\n      ? (...args: Arguments) => Promise<IValidation<R>>\r\n      : (...args: Arguments) => IValidation<Output>\r\n    : never;\r\n  export function validateParameters;\r\n  export function validateReturn;\r\n\r\n  export function validateEqualsFunction;\r\n  export function validateEqualsParameters;\r\n  export function validateEqualsReturn;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nValidates a function.typia.functional.validateFunction<T>() validates a function, by wrapping the parameter function and checking its paramters and return value through typia.validate<T>() function. If some parameter or return value does not match the expected type, it returns a IValidation.IFailure typed object. Otherwise, it returns a IValidation.ISuccess typed object instead.For reference, IValidation.IError.path would be a little bit different with individual typia.validate<T>() function. If IValidation.IError occurs from some parameter, the path wouold start from $input.parameters[<index>]. Otherwise the path would start from $input.return.\n$input.parameters[0].~\n$input.return.~\nBy the way, if you don't want to validate both paramters and return value, but one of them, you can use typia.functional.validateParameters<T>() or typia.functional.validateReturn<T>() instead. Otherwise, if you want to prohibit superfluous properties, typia.functional.validateEqualsFunction<T>() would be helpful.Also, if what you want is not retrieving every type errors, but just finding the first type error, utilize typia.functional.assertFunction<T>() function instead. Otherwise, you don't need the reason why, but just want to know whether the function is valid or not, use typia.functional.isFunction<T>() function.\nimport typia from \"typia\";\r\n\r\ntypia.functional.validateFunction(\r\n  (x: number, y: number) => x + y,\r\n)(3, 4);\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n((x, y) => {\r\n  const paramResults = [\r\n    ((input) => {\r\n      const errors = [];\r\n      const __is = (input) => {\r\n        return \"number\" === typeof input;\r\n      };\r\n      if (false === __is(input)) {\r\n        const $report =\r\n          typia_1.default.functional.validateFunction.report(errors);\r\n        ((input, _path, _exceptionable = true) => {\r\n          return (\r\n            \"number\" === typeof input ||\r\n            $report(true, {\r\n              path: _path + \"\",\r\n              expected: \"number\",\r\n              value: input,\r\n            })\r\n          );\r\n        })(input, \"$input\", true);\r\n      }\r\n      const success = 0 === errors.length;\r\n      return {\r\n        success,\r\n        errors,\r\n        data: success ? input : undefined,\r\n      };\r\n    })(x),\r\n    ((input) => {\r\n      const errors = [];\r\n      const __is = (input) => {\r\n        return \"number\" === typeof input;\r\n      };\r\n      if (false === __is(input)) {\r\n        const $report =\r\n          typia_1.default.functional.validateFunction.report(errors);\r\n        ((input, _path, _exceptionable = true) => {\r\n          return (\r\n            \"number\" === typeof input ||\r\n            $report(true, {\r\n              path: _path + \"\",\r\n              expected: \"number\",\r\n              value: input,\r\n            })\r\n          );\r\n        })(input, \"$input\", true);\r\n      }\r\n      const success = 0 === errors.length;\r\n      return {\r\n        success,\r\n        errors,\r\n        data: success ? input : undefined,\r\n      };\r\n    })(y),\r\n  ].filter((r) => false === r.success);\r\n  if (paramResults.length > 0)\r\n    return {\r\n      success: false,\r\n      errors: paramResults\r\n        .map((r, i) =>\r\n          r.errors.map((error) => ({\r\n            ...error,\r\n            path: error.path.replace(\"$input\", `$input.parameters[${i}]`),\r\n          })),\r\n        )\r\n        .flat(),\r\n    };\r\n  const result = ((input) => {\r\n    const errors = [];\r\n    const __is = (input) => {\r\n      return true;\r\n    };\r\n    if (false === __is(input)) {\r\n      const $report =\r\n        typia_1.default.functional.validateFunction.report(errors);\r\n      ((input, _path, _exceptionable = true) => {\r\n        return true;\r\n      })(input, \"$input\", true);\r\n    }\r\n    const success = 0 === errors.length;\r\n    return {\r\n      success,\r\n      errors,\r\n      data: success ? input : undefined,\r\n    };\r\n  })(((x, y) => x + y)(x, y));\r\n  if (!result.success)\r\n    result.errors = result.errors.map((error) => ({\r\n      ...error,\r\n      path: error.path.replace(\"$input\", \"$input.return\"),\r\n    }));\r\n  return result;\r\n})(3, 4);"}},"/":{"title":"Index","data":{"key-features#Key Features":"","sponsors#Sponsors":"Thanks for your support.Your donation would encourage typia development."}},"/playground":{"title":"Index","data":{}},"/docs/utilization/nestjs":{"title":"Nestjs","data":{"":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: superfast decorators using typia\n@nestia/sdk: evolved SDK and Swagger generators\n@nestia/migrate: Swagger to NestJS\nnestia: just CLI (command line interface) tool\nimport { Controller } from \"@nestjs/common\";\r\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\r\n\r\nimport type { IBbsArticle } from \"@bbs-api/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Store a new content.\r\n   *\r\n   * @param input Content to store\r\n   * @returns Newly archived article\r\n   */\r\n  @TypedRoute.Post() // 200x faster and safer JSON.stringify()\r\n  public async store(\r\n    @TypedBody() input: IBbsArticle.IStore, // 20,000x faster validator\r\n  ): Promise<IBbsArticle>;\r\n    // do not need DTO class definition,\r\n    // just fine with interface\r\n}\nLeft: NestJS server code\nRight: Client code using SDK"}},"/docs/utilization/prisma":{"title":"Prisma","data":{"":"model bbs_articles {\r\n  id String @id @db.Uuid /// @format uuid\r\n  created_at DateTime @db.Timestamptz\r\n\r\n  /// @minItems 1\r\n  snapshots bbs_article_snapshots[]\r\n}\r\n\r\nmodel bbs_article_snapshots {\r\n  id String @id @db.Uuid /// @format uuid\r\n  bbs_article_id String @db.Uuid /// @format uuid\r\n  format String @db.VarChar\r\n\r\n  /// @minLength 5\r\n  /// @maxLength 80\r\n  title String @db.VarChar\r\n  body String\r\n  created_at DateTime @db.Timestamptz\r\n\r\n  article bbs_articles @relation(fields: [bbs_article_id], references: [id])\r\n}\n/**\r\n * Model bbs_articles\r\n */\r\nexport type bbs_articles = {\r\n  /**\r\n   * @format uuid\r\n   */\r\n  id: string\r\n  created_at: Date\r\n}\r\n\r\n/**\r\n * Model bbs_article_snapshots\r\n */\r\nexport type bbs_article_snapshots = {\r\n  /**\r\n   * @format uuid\r\n   */\r\n  id: string\r\n  /**\r\n   * @format uuid\r\n   */\r\n  bbs_article_id: string\r\n  format: string\r\n  /**\r\n   * @minLength 5\r\n   * @maxLength 80\r\n   */\r\n  title: string\r\n  body: string\r\n  created_at: Date\r\n}\nWhen defining prisma.schema file, you can write comment tags just by using /// statement.After the definition, you utillize some validate function like typia.assert<T>(), for type safe insertion."}},"/docs/json/schema":{"title":"Schema","data":{"application-function#application() function":"export namespace json {\r\n  export function application<\r\n    Schemas extends unknown[],\r\n    Purpose extends \"ajv\" | \"swagger\" = \"swagger\",\r\n    Surplus extends boolean = false,\r\n  >(): IJsonApplication;\r\n}\nexport interface IJsonApplication {\r\n  schemas: IJsonSchema[];\r\n  components: IJsonComponents;\r\n  purpose: \"swagger\" | \"ajv\";\r\n  surplus: boolean;\r\n}\nexport interface IJsonComponents {\r\n  schemas: Record<string, IJsonComponents.IAlias>;\r\n}\r\nexport namespace IJsonComponents {\r\n  export type IAlias = IJsonSchema & IIndentified;\r\n  interface IIdentified {\r\n    $id?: undefined | string;\r\n    $recursiveAnchor?: undefined | boolean;\r\n  }\r\n}\nexport type IJsonSchema = IJsonSchema.Known | IJsonSchema.IUnknown;\r\nexport namespace IJsonSchema {\r\n  export type Known =\r\n    | IEnumeration<\"boolean\">\r\n    | IEnumeration<\"number\">\r\n    | IEnumeration<\"string\">\r\n    | IBoolean\r\n    | IInteger\r\n    | INumber\r\n    | IString\r\n    | IArray\r\n    | ITuple\r\n    | IObject\r\n    | IReference\r\n    | INullOnly\r\n    | IOneOf;\r\n\r\n  export interface IUnknown extends IAttribute {\r\n    type?: undefined | undefined;\r\n  }\r\n\r\n  /* -----------------------------------------------------------\r\n        ATOMICS\r\n    ----------------------------------------------------------- */\r\n  export interface IEnumeration<\r\n    Literal extends Exclude<Atomic.Literal, \"bigint\">,\r\n  > extends Omit<IAtomic<Literal>, \"x-typia-typeTags\"> {\r\n    enum: Array<Atomic.Mapper[Literal]>;\r\n  }\r\n  export interface IAtomic<Literal extends Exclude<Atomic.Literal, \"bigint\">>\r\n    extends ISignificant<Literal> {\r\n    default?: undefined | Atomic.Mapper[Literal];\r\n  }\r\n  export interface IString extends IAtomic<\"string\"> {\r\n    minLength?: undefined | (number & Type<\"uint32\">);\r\n    maxLength?: undefined | (number & Type<\"uint32\">);\r\n    pattern?: undefined | string;\r\n    format?:\r\n      | undefined\r\n      | \"binary\"\r\n      | \"byte\"\r\n      | \"password\"\r\n      | \"regex\"\r\n      | \"uuid\"\r\n      | \"email\"\r\n      | \"hostname\"\r\n      | \"idn-email\"\r\n      | \"idn-hostname\"\r\n      | \"iri\"\r\n      | \"iri-reference\"\r\n      | \"ipv4\"\r\n      | \"ipv6\"\r\n      | \"uri\"\r\n      | \"uri-reference\"\r\n      | \"uri-template\"\r\n      | \"url\"\r\n      | \"date-time\"\r\n      | \"date\"\r\n      | \"time\"\r\n      | \"duration\"\r\n      | \"json-pointer\"\r\n      | \"relative-json-pointer\"\r\n      | (string & {});\r\n    \"x-typia-typeTags\"?: undefined | IMetadataTypeTag[];\r\n  }\r\n  export interface INumber extends IAtomic<\"number\"> {\r\n    minimum?: undefined | number;\r\n    maximum?: undefined | number;\r\n    exclusiveMinimum?: undefined | boolean;\r\n    exclusiveMaximum?: undefined | boolean;\r\n    multipleOf?: undefined | number;\r\n    \"x-typia-typeTags\"?: undefined | IMetadataTypeTag[];\r\n  }\r\n  export interface IInteger extends IAtomic<\"integer\"> {\r\n    minimum?: undefined | (number & Type<\"int32\">);\r\n    maximum?: undefined | (number & Type<\"int32\">);\r\n    exclusiveMinimum?: undefined | boolean;\r\n    exclusiveMaximum?: undefined | boolean;\r\n    multipleOf?: undefined | (number & Type<\"int32\">);\r\n    \"x-typia-typeTags\"?: undefined | IMetadataTypeTag[];\r\n  }\r\n  export interface IBoolean extends IAtomic<\"boolean\"> {\r\n    \"x-typia-typeTags\"?: undefined | IMetadataTypeTag[];\r\n  }\r\n\r\n  /* -----------------------------------------------------------\r\n        OBJECTS\r\n    ----------------------------------------------------------- */\r\n  export interface IArray extends ISignificant<\"array\"> {\r\n    items: IJsonSchema;\r\n    minItems?: undefined | (number & Type<\"uint32\">);\r\n    maxItems?: undefined | (number & Type<\"uint32\">);\r\n    \"x-typia-tuple\"?: undefined | ITuple;\r\n    \"x-typia-typeTags\"?: undefined | IMetadataTypeTag[];\r\n  }\r\n  export interface ITuple extends ISignificant<\"array\"> {\r\n    items: IJsonSchema[];\r\n    minItems: number & Type<\"uint32\">;\r\n    maxItems?: undefined | (number & Type<\"uint32\">);\r\n  }\r\n  export interface IObject extends ISignificant<\"object\"> {\r\n    properties: Record<string, IJsonSchema>;\r\n    required?: undefined | string[];\r\n    patternProperties?: undefined | Record<string, IJsonSchema>;\r\n    additionalProperties?: undefined | IJsonSchema;\r\n    \"x-typia-patternProperties\"?: undefined | Record<string, IJsonSchema>;\r\n    \"x-typia-additionalProperties\"?: undefined | IJsonSchema;\r\n  }\r\n  export interface IReference extends IAttribute {\r\n    $ref: string;\r\n  }\r\n  export interface INullOnly extends IAttribute {\r\n    type: \"null\";\r\n  }\r\n\r\n  /* -----------------------------------------------------------\r\n        MISCELLANEOUS\r\n    ----------------------------------------------------------- */\r\n  export interface IOneOf extends IAttribute {\r\n    oneOf: IJsonSchema[];\r\n  }\r\n\r\n  export interface ISignificant<Literal extends string> extends IAttribute {\r\n    type: Literal;\r\n\r\n    /**\r\n     * Only when swagger mode.\r\n     */\r\n    nullable?: undefined | boolean;\r\n  }\r\n  export interface IAttribute {\r\n    deprecated?: undefined | boolean;\r\n    title?: undefined | string;\r\n    description?: undefined | string;\r\n    \"x-typia-jsDocTags\"?: undefined | IJsDocTagInfo[];\r\n    \"x-typia-required\"?: undefined | boolean;\r\n    \"x-typia-optional\"?: undefined | boolean;\r\n    \"x-typia-rest\"?: undefined | boolean;\r\n  }\r\n}\nJSON schema generator.\nDefinitions:\nIJsonApplication\nIJsonComponents\nIJsonSchema\nWhen you need JSON schema, do not write it by yourself, but just call typia.json.application() function.If you call the typia.json.application() with specialization of target Schemas, typia will analyze your Schemas and generate JSON schema definition in the compilation level. However, note that, JSON schema definitions of AJV and Swagger are a little bit different. Therefore, you have to consider which value to assign in the Purpose argument.\nSwagger can't express tuple type\nSwagger can't express pattern property\nimport typia, { tags } from \"typia\";\r\n\r\nexport const MemberSchema = typia.json.application<[IMember], \"ajv\">();\r\n\r\ninterface IMember {\r\n  /**\r\n   * Unique user ID generated by server.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n\r\n  /**\r\n   * Email address of the member.\r\n   */\r\n  email: string & tags.Format<\"email\">;\r\n\r\n  /**\r\n   * Age of the member.\r\n   *\r\n   * For reference, only adult can be a member.\r\n   */\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MemberSchema = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nexports.MemberSchema = {\r\n  schemas: [\r\n    {\r\n      $ref: \"#/components/schemas/IMember\",\r\n    },\r\n  ],\r\n  components: {\r\n    schemas: {\r\n      IMember: {\r\n        $id: \"#/components/schemas/IMember\",\r\n        type: \"object\",\r\n        properties: {\r\n          id: {\r\n            type: \"string\",\r\n            format: \"uuid\",\r\n            title: \"Unique user ID generated by server\",\r\n            description: \"Unique user ID generated by server.\",\r\n          },\r\n          email: {\r\n            type: \"string\",\r\n            format: \"email\",\r\n            title: \"Email address of the member\",\r\n            description: \"Email address of the member.\",\r\n          },\r\n          age: {\r\n            type: \"integer\",\r\n            minimum: 19,\r\n            exclusiveMinimum: true,\r\n            maximum: 100,\r\n            title: \"Age of the member\",\r\n            description:\r\n              \"Age of the member.\\n\\nFor reference, only adult can be a member.\",\r\n          },\r\n        },\r\n        required: [\"id\", \"email\", \"age\"],\r\n      },\r\n    },\r\n  },\r\n  purpose: \"ajv\",\r\n  surplus: false,\r\n};","specialization#Specialization":"You can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\n@default {value}\nLet's see how those type tags, comment tags and description comments are working with example code.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const SpecialTagSchema = typia.json.application<[Special], \"swagger\">();\r\n\r\ninterface Special {\r\n  /**\r\n   * Deprecated tags are just used for marking.\r\n   *\r\n   * @title Unsigned integer\r\n   * @deprecated\r\n   */\r\n  type: number & tags.Type<\"int32\">;\r\n\r\n  /**\r\n   * Internal tagged property never be shown in JSON schema.\r\n   *\r\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\r\n   *\r\n   * @internal\r\n   */\r\n  internal: number[];\r\n\r\n  /**\r\n   * Hidden tagged property never be shown in JSON schema.\r\n   *\r\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\r\n   *\r\n   * @hidden\r\n   */\r\n  hidden: boolean;\r\n\r\n  /**\r\n   * You can limit the range of number.\r\n   *\r\n   * @exclusiveMinimum 19\r\n   * @maximum 100\r\n   * @default 30\r\n   */\r\n  number?: number;\r\n\r\n  /**\r\n   * You can limit the length of string.\r\n   *\r\n   * Also, multiple range conditions are also possible.\r\n   */\r\n  string: string &\r\n    (\r\n      | (tags.MinLength<3> & tags.MaxLength<24>)\r\n      | (tags.MinLength<40> & tags.MaxLength<100>)\r\n    );\r\n\r\n  /**\r\n   * You can limit the pattern of string.\r\n   *\r\n   * @pattern ^[a-z]+$\r\n   */\r\n  pattern: string;\r\n\r\n  /**\r\n   * You can limit the format of string.\r\n   *\r\n   * @format date-time\r\n   */\r\n  format: string | null;\r\n\r\n  /**\r\n   * In the Array case, possible to restrict its elements.\r\n   */\r\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SpecialTagSchema = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nexports.SpecialTagSchema = {\r\n  schemas: [\r\n    {\r\n      $ref: \"#/components/schemas/Special\",\r\n    },\r\n  ],\r\n  components: {\r\n    schemas: {\r\n      Special: {\r\n        type: \"object\",\r\n        properties: {\r\n          type: {\r\n            type: \"integer\",\r\n            deprecated: true,\r\n            title: \"Unsigned integer\",\r\n            description: \"Deprecated tags are just used for marking.\",\r\n          },\r\n          number: {\r\n            type: \"number\",\r\n            minimum: 19,\r\n            exclusiveMinimum: true,\r\n            maximum: 100,\r\n            default: 30,\r\n            title: \"You can limit the range of number\",\r\n            description: \"You can limit the range of number.\",\r\n          },\r\n          string: {\r\n            oneOf: [\r\n              {\r\n                type: \"string\",\r\n                maxLength: 24,\r\n                minLength: 3,\r\n              },\r\n              {\r\n                type: \"string\",\r\n                maxLength: 100,\r\n                minLength: 40,\r\n              },\r\n            ],\r\n            title: \"You can limit the length of string\",\r\n            description:\r\n              \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\r\n          },\r\n          pattern: {\r\n            type: \"string\",\r\n            pattern: \"^[a-z]+$\",\r\n            title: \"You can limit the pattern of string\",\r\n            description: \"You can limit the pattern of string.\",\r\n          },\r\n          format: {\r\n            type: \"string\",\r\n            format: \"date-time\",\r\n            nullable: true,\r\n            title: \"You can limit the format of string\",\r\n            description: \"You can limit the format of string.\",\r\n          },\r\n          array: {\r\n            type: \"array\",\r\n            items: {\r\n              type: \"string\",\r\n              format: \"uuid\",\r\n            },\r\n            minItems: 3,\r\n            title: \"In the Array case, possible to restrict its elements\",\r\n            description:\r\n              \"In the Array case, possible to restrict its elements.\",\r\n          },\r\n        },\r\n        nullable: false,\r\n        required: [\"type\", \"string\", \"pattern\", \"format\", \"array\"],\r\n      },\r\n    },\r\n  },\r\n  purpose: \"swagger\",\r\n  surplus: false,\r\n};","restrictions#Restrictions":"JSON schema does not support bigint type.So if you use bigint type in one of your onetarget schemas, typia will make compile error like below.\nimport typia, { tags } from \"typia\";\r\n\r\ninterface Something {\r\n  bigint: bigint;\r\n  array: bigint[];\r\n  nested: Nested;\r\n}\r\ninterface Nested {\r\n  uint64: bigint & tags.Type<\"uint64\">;\r\n}\r\n\r\ntypia.json.application<[Something], \"ajv\">();\nmain.ts:12:1 - error TS(typia.json.application): unsupported type detected\r\n\r\n- Something.bigint: bigint\r\n  - JSON does not support bigint type.\r\n\r\n- Something.array: bigint\r\n  - JSON does not support bigint type.\r\n\r\n- Nested.uint64: (bigint & Type<\"uint64\">)\r\n  - JSON does not support bigint type.\nAlso, if you put any type of native classes like Map or Uint8Array, it would also be error, either. By the way, only Date class is exceptional, and it would be considered as string & Format<\"date-time\"> type like below.\nimport typia from \"typia\";\r\n\r\ninterface Native {\r\n  date: Date;\r\n}\r\ntypia.json.application<[Native], \"ajv\">();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n({\r\n  schemas: [\r\n    {\r\n      $ref: \"#/components/schemas/Native\",\r\n    },\r\n  ],\r\n  components: {\r\n    schemas: {\r\n      Native: {\r\n        $id: \"#/components/schemas/Native\",\r\n        type: \"object\",\r\n        properties: {\r\n          date: {\r\n            type: \"string\",\r\n            format: \"date-time\",\r\n          },\r\n        },\r\n        required: [\"date\"],\r\n      },\r\n    },\r\n  },\r\n  purpose: \"ajv\",\r\n  surplus: false,\r\n});"}},"/docs/json/parse":{"title":"Parse","data":{"parse-functions#parse() functions":"export namespace json {\r\n  export function isParse<T>(input: string): Primitive<T> | null;\r\n  export function assertParse<T>(input: string): Primitive<T>;\r\n  export function validateParse<T>(input: string): IValidation<Primitive<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Primitive type of JSON.\r\n *\r\n * `Primitive<T>` is a TMP (Type Meta Programming) type which converts\r\n * its argument as a primitive type within framework JSON.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be an empty object (`{}`).\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom method\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the primitive object.\r\n *\r\n * In addition, if the target argument is a type of custom class and it has a special\r\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\r\n * but `Primitive<ReturnType<Instance.toJSON>>`.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `String`                | `string`\r\n * `Class`                 | `object`\r\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\r\n * Native Class            | never\r\n * Others                  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n * @author Michael - https://github.com/8471919\r\n */\r\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\r\n  ? T\r\n  : PrimitiveMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype PrimitiveMain<Instance> = Instance extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<Instance> extends bigint\r\n  ? never\r\n  : ValueOf<Instance> extends boolean | number | string\r\n  ? ValueOf<Instance>\r\n  : Instance extends Function\r\n  ? never\r\n  : ValueOf<Instance> extends object\r\n  ? Instance extends object\r\n    ? Instance extends NativeClass\r\n      ? never\r\n      : Instance extends IJsonable<infer Raw>\r\n      ? ValueOf<Raw> extends object\r\n        ? Raw extends object\r\n          ? PrimitiveObject<Raw> // object would be primitified\r\n          : never // cannot be\r\n        : ValueOf<Raw> // atomic value\r\n      : PrimitiveObject<Instance> // object would be primitified\r\n    : never // cannot be\r\n  : ValueOf<Instance>;\r\n\r\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\r\n  ? IsTuple<Instance> extends true\r\n    ? PrimitiveTuple<Instance>\r\n    : PrimitiveMain<T>[]\r\n  : {\r\n      [P in keyof Instance]: PrimitiveMain<Instance[P]>;\r\n    };\r\n\r\ntype PrimitiveTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [PrimitiveMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [PrimitiveMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>]\r\n  : [];\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype NativeClass =\r\n  | Set<any>\r\n  | Map<any, any>\r\n  | WeakSet<any>\r\n  | WeakMap<any, any>\r\n  | Uint8Array\r\n  | Uint8ClampedArray\r\n  | Uint16Array\r\n  | Uint32Array\r\n  | BigUint64Array\r\n  | Int8Array\r\n  | Int16Array\r\n  | Int32Array\r\n  | BigInt64Array\r\n  | Float32Array\r\n  | Float64Array\r\n  | ArrayBuffer\r\n  | SharedArrayBuffer\r\n  | DataView;\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer U>\r\n    ? Instance extends U\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\r\n\r\ninterface IJsonable<T> {\r\n  toJSON(): T;\r\n}\nType safe JSON parser.Unlike native JSON.parse() function which returns any typed instance without type checking, typia.json.assertParse<T>() function validates instance type after the parsing. If the parsed value is not following the promised type T, it throws TypeGuardError with the first type error info.If you want to know every type error infos detaily, you can use typia.json.validateParse<T>() function instead. Otherwise, you just only want to know whether the parsed value is following the type T or not, just call typia.json.isParse<T>() function.\ntypia.json.isParse<T>(): JSON.parse() + typia.is<T>()\ntypia.json.assertParse<T>(): JSON.parse() + typia.assert<T>()\ntypia.json.validateParse<T>(): JSON.parse() + typia.validate<T>()\nLook at the below code, then you may understand how the typia.json.assertParse<T>() function works.\nimport typia, { tags } from \"typia\";\r\n\r\nconst json: string = JSON.stringify(typia.random<IMember>());\r\nconst parsed: IMember = typia.json.assertParse<IMember>(json);\r\n\r\nconsole.log(json === JSON.stringify(parsed)); // true\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst json = JSON.stringify(\r\n  ((generator) => {\r\n    const $generator = typia_1.default.random.generator;\r\n    const $ro0 = (_recursive = false, _depth = 0) => ({\r\n      id:\r\n        (generator?.customs ?? $generator.customs)?.string?.([\r\n          {\r\n            name: 'Format<\"uuid\">',\r\n            kind: \"format\",\r\n            value: \"uuid\",\r\n          },\r\n        ]) ?? (generator?.uuid ?? $generator.uuid)(),\r\n      email:\r\n        (generator?.customs ?? $generator.customs)?.string?.([\r\n          {\r\n            name: 'Format<\"email\">',\r\n            kind: \"format\",\r\n            value: \"email\",\r\n          },\r\n        ]) ?? (generator?.email ?? $generator.email)(),\r\n      age:\r\n        (generator?.customs ?? $generator.customs)?.number?.([\r\n          {\r\n            name: 'Type<\"uint32\">',\r\n            kind: \"type\",\r\n            value: \"uint32\",\r\n          },\r\n          {\r\n            name: \"ExclusiveMinimum<19>\",\r\n            kind: \"exclusiveMinimum\",\r\n            value: 19,\r\n          },\r\n          {\r\n            name: \"Maximum<100>\",\r\n            kind: \"maximum\",\r\n            value: 100,\r\n          },\r\n        ]) ?? (generator?.integer ?? $generator.integer)(19, 100),\r\n    });\r\n    return $ro0();\r\n  })(),\r\n);\r\nconst parsed = ((input) => {\r\n  const assert = (input) => {\r\n    const __is = (input) => {\r\n      return (\r\n        \"object\" === typeof input &&\r\n        null !== input &&\r\n        \"string\" === typeof input.id &&\r\n        /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n          input.id,\r\n        ) &&\r\n        \"string\" === typeof input.email &&\r\n        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n          input.email,\r\n        ) &&\r\n        \"number\" === typeof input.age &&\r\n        Math.floor(input.age) === input.age &&\r\n        0 <= input.age &&\r\n        input.age <= 4294967295 &&\r\n        19 < input.age &&\r\n        input.age <= 100\r\n      );\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.json.assertParse.guard;\r\n        const $ao0 = (input, _path, _exceptionable = true) =>\r\n          ((\"string\" === typeof input.id &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input.id,\r\n            ) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".id\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input.id,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: '(string & Format<\"uuid\">)',\r\n              value: input.id,\r\n            })) &&\r\n          ((\"string\" === typeof input.email &&\r\n            (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n              input.email,\r\n            ) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".email\",\r\n                expected: 'string & Format<\"email\">',\r\n                value: input.email,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".email\",\r\n              expected: '(string & Format<\"email\">)',\r\n              value: input.email,\r\n            })) &&\r\n          ((\"number\" === typeof input.age &&\r\n            ((Math.floor(input.age) === input.age &&\r\n              0 <= input.age &&\r\n              input.age <= 4294967295) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: 'number & Type<\"uint32\">',\r\n                value: input.age,\r\n              })) &&\r\n            (19 < input.age ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & ExclusiveMinimum<19>\",\r\n                value: input.age,\r\n              })) &&\r\n            (input.age <= 100 ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & Maximum<100>\",\r\n                value: input.age,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected:\r\n                '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n              value: input.age,\r\n            }));\r\n        return (\r\n          (((\"object\" === typeof input && null !== input) ||\r\n            $guard(true, {\r\n              path: _path + \"\",\r\n              expected: \"IMember\",\r\n              value: input,\r\n            })) &&\r\n            $ao0(input, _path + \"\", true)) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IMember\",\r\n            value: input,\r\n          })\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  };\r\n  input = JSON.parse(input);\r\n  return assert(input);\r\n})(json);\r\nconsole.log(json === JSON.stringify(parsed)); // true\n/**\r\n * Primitive type of JSON.\r\n *\r\n * `Primitive<T>` is a TMP (Type Meta Programming) type which converts\r\n * its argument as a primitive type within framework JSON.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be an empty object (`{}`).\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom method\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the primitive object.\r\n *\r\n * In addition, if the target argument is a type of custom class and it has a special\r\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\r\n * but `Primitive<ReturnType<Instance.toJSON>>`.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `String`                | `string`\r\n * `Class`                 | `object`\r\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\r\n * Native Class            | never\r\n * Others                  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n * @author Michael - https://github.com/8471919\r\n */\r\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\r\n  ? T\r\n  : PrimitiveMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype PrimitiveMain<Instance> = Instance extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<Instance> extends bigint\r\n  ? never\r\n  : ValueOf<Instance> extends boolean | number | string\r\n  ? ValueOf<Instance>\r\n  : Instance extends Function\r\n  ? never\r\n  : ValueOf<Instance> extends object\r\n  ? Instance extends object\r\n    ? Instance extends NativeClass\r\n      ? never\r\n      : Instance extends IJsonable<infer Raw>\r\n      ? ValueOf<Raw> extends object\r\n        ? Raw extends object\r\n          ? PrimitiveObject<Raw> // object would be primitified\r\n          : never // cannot be\r\n        : ValueOf<Raw> // atomic value\r\n      : PrimitiveObject<Instance> // object would be primitified\r\n    : never // cannot be\r\n  : ValueOf<Instance>;\r\n\r\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\r\n  ? IsTuple<Instance> extends true\r\n    ? PrimitiveTuple<Instance>\r\n    : PrimitiveMain<T>[]\r\n  : {\r\n      [P in keyof Instance]: PrimitiveMain<Instance[P]>;\r\n    };\r\n\r\ntype PrimitiveTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [PrimitiveMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [PrimitiveMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>]\r\n  : [];\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype NativeClass =\r\n  | Set<any>\r\n  | Map<any, any>\r\n  | WeakSet<any>\r\n  | WeakMap<any, any>\r\n  | Uint8Array\r\n  | Uint8ClampedArray\r\n  | Uint16Array\r\n  | Uint32Array\r\n  | BigUint64Array\r\n  | Int8Array\r\n  | Int16Array\r\n  | Int32Array\r\n  | BigInt64Array\r\n  | Float32Array\r\n  | Float64Array\r\n  | ArrayBuffer\r\n  | SharedArrayBuffer\r\n  | DataView;\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer U>\r\n    ? Instance extends U\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\r\n\r\ninterface IJsonable<T> {\r\n  toJSON(): T;\r\n}","reusable-functions#Reusable functions":"export namespace json {\r\n  export function createIsParse<T>(): (input: string) => Primitive<T> | null;\r\n  export function createAssertParse<T>(): (input: string) => Primitive<T>;\r\n  export function createValidateParse<T>(): (\r\n    input: string,\r\n  ) => IValidation<Primitive<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nReusable typia.json.isParse<T>() function generators.If you repeat to call typia.json.isParse<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIsParse<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const parseMember = typia.json.createIsParse<IMember>();\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseMember = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst parseMember = (input) => {\r\n  const is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.email &&\r\n      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n        input.email,\r\n      ) &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100\r\n    );\r\n  };\r\n  input = JSON.parse(input);\r\n  return is(input) ? input : null;\r\n};\r\nexports.parseMember = parseMember;"}},"/docs/json/stringify":{"title":"Stringify","data":{"stringify-functions#stringify() functions":"export namespace json {\r\n  export function stringify<T>(input: T): string;\r\n  export function isStringify<T>(input: T | unknown): string | null;\r\n  export function assertStringify<T>(input: T | unknown): string;\r\n  export function validateStringify<T>(input: T | unknown): IValidation<string>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nYou can boost up JSON serialization speed just by calling typia.json.stringify<T>() function. Also, you even can ensure type safety of JSON serialization by calling other functions like typia.json.isStringify() and typia.json.assertStringify() functions.As typia.json.stringify<T>() function writes dedicated JSON serialization code only for the target type T, its performance is much faster than native JSON.stringify() function. However, because of the dedicated optimal JSON serialization code, when wrong typed data comes, unexpected error be occured.Instead, typia supports type safe JSON serialization functions like typia.json.isStringify(). The typia.json.isStringify() is a combination function of typia.is<T>() and typia.json.stringify<T>() function. It checks whether the input value is valid for the target type T or not first, and operate JSON serialization later. If the input value is not matched with the type T, it returns null value.\ntypia.json.isStringify(): typia.is<T>() + typia.json.stringify<T>()\ntypia.json.assertStringify(): typia.assert<T>() + typia.json.stringify<T>()\ntypia.json.validateStringify(): typia.validate<T>() + typia.json.stringify<T>()\nAOT compliation\ntypia.json.isStringify() and other similar functions are still much faster than native JSON.stringify() function, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\nimport typia, { tags } from \"typia\";\r\n\r\nconst department: IDepartment = typia.random<IDepartment>();\r\nconst json: string | null = typia.json.isStringify(department);\r\n\r\nconsole.log(json); // not null, but string\r\n\r\ninterface IDepartment {\r\n    id: string & tags.Format<\"uuid\">;\r\n    name: string & tags.MinLength<3>;\r\n    limit: number & tags.Type<\"int32\">;\r\n    clerks: IClerk[];\r\n}\r\ninterface IClerk {\r\n    name: string;\r\n    age: number \r\n        & tags.Type<\"uint32\"> \r\n        & tags.ExclusiveMinimum<19> \r\n        & tags.Maximum<100>;\r\n    authority: number;\r\n    joined_at: string & tags.Format<\"date\">;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst department = ((generator) => {\r\n  const $generator = typia_1.default.random.generator;\r\n  const $ro0 = (_recursive = false, _depth = 0) => ({\r\n    id:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"uuid\">',\r\n          kind: \"format\",\r\n          value: \"uuid\",\r\n        },\r\n      ]) ?? (generator?.uuid ?? $generator.uuid)(),\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: \"MinLength<3>\",\r\n          kind: \"minLength\",\r\n          value: 3,\r\n        },\r\n      ]) ??\r\n      (generator?.string ?? $generator.string)(\r\n        (generator?.integer ?? $generator.integer)(3, 25),\r\n      ),\r\n    limit:\r\n      (generator?.customs ?? $generator.customs)?.number?.([\r\n        {\r\n          name: 'Type<\"int32\">',\r\n          kind: \"type\",\r\n          value: \"int32\",\r\n        },\r\n      ]) ?? (generator?.integer ?? $generator.integer)(0, 100),\r\n    clerks: (generator?.array ?? $generator.array)(() =>\r\n      $ro1(_recursive, _recursive ? 1 + _depth : _depth),\r\n    ),\r\n  });\r\n  const $ro1 = (_recursive = false, _depth = 0) => ({\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n      (generator?.string ?? $generator.string)(),\r\n    age:\r\n      (generator?.customs ?? $generator.customs)?.number?.([\r\n        {\r\n          name: 'Type<\"uint32\">',\r\n          kind: \"type\",\r\n          value: \"uint32\",\r\n        },\r\n        {\r\n          name: \"ExclusiveMinimum<19>\",\r\n          kind: \"exclusiveMinimum\",\r\n          value: 19,\r\n        },\r\n        {\r\n          name: \"Maximum<100>\",\r\n          kind: \"maximum\",\r\n          value: 100,\r\n        },\r\n      ]) ?? (generator?.integer ?? $generator.integer)(19, 100),\r\n    authority:\r\n      (generator?.customs ?? $generator.customs)?.number?.([]) ??\r\n      (generator?.number ?? $generator.number)(0, 100),\r\n    joined_at:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"date\">',\r\n          kind: \"format\",\r\n          value: \"date\",\r\n        },\r\n      ]) ?? (generator?.date ?? $generator.date)(),\r\n  });\r\n  return $ro0();\r\n})();\r\nconst json = ((input) => {\r\n  const is = (input) => {\r\n    const $io0 = (input) =>\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.name &&\r\n      3 <= input.name.length &&\r\n      \"number\" === typeof input.limit &&\r\n      Math.floor(input.limit) === input.limit &&\r\n      -2147483648 <= input.limit &&\r\n      input.limit <= 2147483647 &&\r\n      Array.isArray(input.clerks) &&\r\n      input.clerks.every(\r\n        (elem) => \"object\" === typeof elem && null !== elem && $io1(elem),\r\n      );\r\n    const $io1 = (input) =>\r\n      \"string\" === typeof input.name &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100 &&\r\n      \"number\" === typeof input.authority &&\r\n      !Number.isNaN(input.authority) &&\r\n      \"string\" === typeof input.joined_at &&\r\n      /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n    return \"object\" === typeof input && null !== input && $io0(input);\r\n  };\r\n  const stringify = (input) => {\r\n    const $io1 = (input) =>\r\n      \"string\" === typeof input.name &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100 &&\r\n      \"number\" === typeof input.authority &&\r\n      \"string\" === typeof input.joined_at &&\r\n      /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n    const $string = typia_1.default.json.isStringify.string;\r\n    const $so0 = (input) =>\r\n      `{\"id\":${$string(input.id)},\"name\":${$string(input.name)},\"limit\":${input.limit},\"clerks\":${`[${input.clerks.map((elem) => `{\"name\":${$string(elem.name)},\"age\":${elem.age},\"authority\":${elem.authority},\"joined_at\":${$string(elem.joined_at)}}`).join(\",\")}]`}}`;\r\n    return $so0(input);\r\n  };\r\n  return is(input) ? stringify(input) : null;\r\n})(department);\r\nconsole.log(json); // not null, but string","reusable-functions#Reusable functions":"export namespace json {\r\n  export function createStringify<T>: (input: T) => string;\r\n  export function createIsStringify<T>: (\r\n      input: T | unknown\r\n  ) => string | null;\r\n  export function createAssertStringify<T>: (\r\n      input: T | unknown\r\n  ) => string;\r\n  export function createValidateStringify<T>: (\r\n      input: T | unknown\r\n  ) => IValidation<string>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nReusable typia.json.stringify<T>() function generators.If you repeat to call typia.json.stringify<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.json.createStringify<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const assertDepartment = typia.json.createAssertStringify<IDepartment>();\r\n\r\ninterface IDepartment {\r\n  id: string & tags.Format<\"uuid\">;\r\n  name: string & tags.MinLength<3>;\r\n  limit: number & tags.Type<\"int32\">;\r\n  clerks: IClerk[];\r\n}\r\ninterface IClerk {\r\n  name: string;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n  authority: number;\r\n  joined_at: string & tags.Format<\"date\">;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.assertDepartment = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst assertDepartment = (input) => {\r\n  const assert = (input) => {\r\n    const __is = (input) => {\r\n      const $io0 = (input) =>\r\n        \"string\" === typeof input.id &&\r\n        /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n          input.id,\r\n        ) &&\r\n        \"string\" === typeof input.name &&\r\n        3 <= input.name.length &&\r\n        \"number\" === typeof input.limit &&\r\n        Math.floor(input.limit) === input.limit &&\r\n        -2147483648 <= input.limit &&\r\n        input.limit <= 2147483647 &&\r\n        Array.isArray(input.clerks) &&\r\n        input.clerks.every(\r\n          (elem) => \"object\" === typeof elem && null !== elem && $io1(elem),\r\n        );\r\n      const $io1 = (input) =>\r\n        \"string\" === typeof input.name &&\r\n        \"number\" === typeof input.age &&\r\n        Math.floor(input.age) === input.age &&\r\n        0 <= input.age &&\r\n        input.age <= 4294967295 &&\r\n        19 < input.age &&\r\n        input.age <= 100 &&\r\n        \"number\" === typeof input.authority &&\r\n        !Number.isNaN(input.authority) &&\r\n        \"string\" === typeof input.joined_at &&\r\n        /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n      return \"object\" === typeof input && null !== input && $io0(input);\r\n    };\r\n    if (false === __is(input))\r\n      ((input, _path, _exceptionable = true) => {\r\n        const $guard = typia_1.default.json.createAssertStringify.guard;\r\n        const $ao0 = (input, _path, _exceptionable = true) =>\r\n          ((\"string\" === typeof input.id &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input.id,\r\n            ) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".id\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input.id,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: '(string & Format<\"uuid\">)',\r\n              value: input.id,\r\n            })) &&\r\n          ((\"string\" === typeof input.name &&\r\n            (3 <= input.name.length ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".name\",\r\n                expected: \"string & MinLength<3>\",\r\n                value: input.name,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: \"(string & MinLength<3>)\",\r\n              value: input.name,\r\n            })) &&\r\n          ((\"number\" === typeof input.limit &&\r\n            ((Math.floor(input.limit) === input.limit &&\r\n              -2147483648 <= input.limit &&\r\n              input.limit <= 2147483647) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".limit\",\r\n                expected: 'number & Type<\"int32\">',\r\n                value: input.limit,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".limit\",\r\n              expected: '(number & Type<\"int32\">)',\r\n              value: input.limit,\r\n            })) &&\r\n          (((Array.isArray(input.clerks) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".clerks\",\r\n              expected: \"Array<IClerk>\",\r\n              value: input.clerks,\r\n            })) &&\r\n            input.clerks.every(\r\n              (elem, _index1) =>\r\n                (((\"object\" === typeof elem && null !== elem) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".clerks[\" + _index1 + \"]\",\r\n                    expected: \"IClerk\",\r\n                    value: elem,\r\n                  })) &&\r\n                  $ao1(\r\n                    elem,\r\n                    _path + \".clerks[\" + _index1 + \"]\",\r\n                    true && _exceptionable,\r\n                  )) ||\r\n                $guard(_exceptionable, {\r\n                  path: _path + \".clerks[\" + _index1 + \"]\",\r\n                  expected: \"IClerk\",\r\n                  value: elem,\r\n                }),\r\n            )) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".clerks\",\r\n              expected: \"Array<IClerk>\",\r\n              value: input.clerks,\r\n            }));\r\n        const $ao1 = (input, _path, _exceptionable = true) =>\r\n          (\"string\" === typeof input.name ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: \"string\",\r\n              value: input.name,\r\n            })) &&\r\n          ((\"number\" === typeof input.age &&\r\n            ((Math.floor(input.age) === input.age &&\r\n              0 <= input.age &&\r\n              input.age <= 4294967295) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: 'number & Type<\"uint32\">',\r\n                value: input.age,\r\n              })) &&\r\n            (19 < input.age ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & ExclusiveMinimum<19>\",\r\n                value: input.age,\r\n              })) &&\r\n            (input.age <= 100 ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & Maximum<100>\",\r\n                value: input.age,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected:\r\n                '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n              value: input.age,\r\n            })) &&\r\n          ((\"number\" === typeof input.authority &&\r\n            !Number.isNaN(input.authority)) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".authority\",\r\n              expected: \"number\",\r\n              value: input.authority,\r\n            })) &&\r\n          ((\"string\" === typeof input.joined_at &&\r\n            (/^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".joined_at\",\r\n                expected: 'string & Format<\"date\">',\r\n                value: input.joined_at,\r\n              }))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".joined_at\",\r\n              expected: '(string & Format<\"date\">)',\r\n              value: input.joined_at,\r\n            }));\r\n        return (\r\n          (((\"object\" === typeof input && null !== input) ||\r\n            $guard(true, {\r\n              path: _path + \"\",\r\n              expected: \"IDepartment\",\r\n              value: input,\r\n            })) &&\r\n            $ao0(input, _path + \"\", true)) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IDepartment\",\r\n            value: input,\r\n          })\r\n        );\r\n      })(input, \"$input\", true);\r\n    return input;\r\n  };\r\n  const stringify = (input) => {\r\n    const $io1 = (input) =>\r\n      \"string\" === typeof input.name &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100 &&\r\n      \"number\" === typeof input.authority &&\r\n      \"string\" === typeof input.joined_at &&\r\n      /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(input.joined_at);\r\n    const $string = typia_1.default.json.createAssertStringify.string;\r\n    const $so0 = (input) =>\r\n      `{\"id\":${$string(input.id)},\"name\":${$string(input.name)},\"limit\":${input.limit},\"clerks\":${`[${input.clerks.map((elem) => `{\"name\":${$string(elem.name)},\"age\":${elem.age},\"authority\":${elem.authority},\"joined_at\":${$string(elem.joined_at)}}`).join(\",\")}]`}}`;\r\n    return $so0(input);\r\n  };\r\n  return stringify(assert(input));\r\n};\r\nexports.assertDepartment = assertDepartment;","performance#Performance":"Comparing JSON serialization speed with others, it is maximum 200x faster than class-transformer.For reference, class-transformer is the most famous library used in NestJS with class-validator. Also, fast-json-stringify is another famous one used in fastify. However, whether they are fast or slow, both of them require extra schema definition, that is different with TypeScript type. If you see the code below without experience of them, you may get shocked: how complicate and inefficient they are:\nfast-json-stringify requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nMeasured on Intel i5-1135g7, Surface Pro 8","server-performance#Server Performance":"Someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/protobuf/decode":{"title":"Decode","data":{"decode-functions#decode() functions":"export namespace protobuf {\r\n  export function decode<T>(buffer: Uint8Array): Resolved<T>;\r\n  export function isDecode<T>(buffer: Uint8Array): Resolved<T> | null;\r\n  export function assertDecode<T>(buffer: Uint8Array): Resolved<T>;\r\n  export function validateDecode<T>(\r\n    buffer: Uint8Array,\r\n  ): IValidation<Resolved<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nProtocol Buffer Decoder.You can easily convert a Protocol Buffer's binary data to a JavaScript object, without any extra Protocol Buffer Message Schema definition. typia.protobuf.decode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally.And then, it converts the binary data to a JavaScript object.By the way, as Protocol Buffer handles binary data directly, there's no way when input binary data was not encoded from the T typed value. In that case, unexpected behavior or internal error would be occured. Therefore, I recommend you to encode binary data of Protocol Buffer from type safe encode functions like below, Use typia.protobuf.encode<T>() function only when you can trust it.\ntypia.protobuf.isEncode<T>()\ntypia.protobuf.assertEncode<T>()\ntypia.protobuf.validateEncode<T>()\nFor reference, typia provides type safe decorators like below, but they are just for additional type validation like number & Minimum<7> or string & Format<\"uuid\"> cases, that are represented by Special Tags. Thus, I repeat that, you've to ensure type safety when using decoder function.\ntypia.protobuf.isDecode<T>(): typia.is<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.assertDecode<T>(): typia.assert<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.validateDecode<T>(): typia.validate<T>() + typia.protobuf.decode<T>()\nAOT compliation\ntypia.protobuf.decode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\nimport typia, { tags } from \"typia\";\r\n\r\ninterface ICustomer {\r\n  id: number & tags.Type<\"int32\">;\r\n  email: string & tags.Format<\"email\">;\r\n  name: string;\r\n  pet: null | ICat | IDog;\r\n  memo: null | Map<string, string>;\r\n  logins: Array<ICustomerLogin>;\r\n}\r\ninterface ICat {\r\n  type: \"cat\";\r\n  name: string;\r\n  ribbon: boolean;\r\n}\r\ninterface IDog {\r\n  type: \"dog\";\r\n  name: string;\r\n  hunt: boolean;\r\n}\r\ninterface ICustomerLogin {\r\n  success: boolean;\r\n  href: string & tags.Format<\"url\">;\r\n  referrer: string & tags.Format<\"url\">;\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  time: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nconst data: ICustomer = typia.random<ICustomer>();\r\nconst encoded: Uint8Array = typia.protobuf.encode(data);\r\ntypia.protobuf.decode<ICustomer>(encoded);\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst data = ((generator) => {\r\n  const $generator = typia_1.default.random.generator;\r\n  const $pick = typia_1.default.random.pick;\r\n  const $ro0 = (_recursive = false, _depth = 0) => ({\r\n    id:\r\n      (generator?.customs ?? $generator.customs)?.number?.([\r\n        {\r\n          name: 'Type<\"int32\">',\r\n          kind: \"type\",\r\n          value: \"int32\",\r\n        },\r\n      ]) ?? (generator?.integer ?? $generator.integer)(0, 100),\r\n    email:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"email\">',\r\n          kind: \"format\",\r\n          value: \"email\",\r\n        },\r\n      ]) ?? (generator?.email ?? $generator.email)(),\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n      (generator?.string ?? $generator.string)(),\r\n    pet: $pick([\r\n      () => null,\r\n      () => $ro1(_recursive, _recursive ? 1 + _depth : _depth),\r\n      () => $ro2(_recursive, _recursive ? 1 + _depth : _depth),\r\n    ])(),\r\n    memo: $pick([\r\n      () => null,\r\n      () =>\r\n        new Map(\r\n          (generator?.array ?? $generator.array)(() => [\r\n            (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n              (generator?.string ?? $generator.string)(),\r\n            (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n              (generator?.string ?? $generator.string)(),\r\n          ]),\r\n        ),\r\n    ])(),\r\n    logins: (generator?.array ?? $generator.array)(() =>\r\n      $ro3(_recursive, _recursive ? 1 + _depth : _depth),\r\n    ),\r\n  });\r\n  const $ro1 = (_recursive = false, _depth = 0) => ({\r\n    type: \"cat\",\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n      (generator?.string ?? $generator.string)(),\r\n    ribbon: (generator?.boolean ?? $generator.boolean)(),\r\n  });\r\n  const $ro2 = (_recursive = false, _depth = 0) => ({\r\n    type: \"dog\",\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n      (generator?.string ?? $generator.string)(),\r\n    hunt: (generator?.boolean ?? $generator.boolean)(),\r\n  });\r\n  const $ro3 = (_recursive = false, _depth = 0) => ({\r\n    success: (generator?.boolean ?? $generator.boolean)(),\r\n    href:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"url\">',\r\n          kind: \"format\",\r\n          value: \"url\",\r\n        },\r\n      ]) ?? (generator?.url ?? $generator.url)(),\r\n    referrer:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"url\">',\r\n          kind: \"format\",\r\n          value: \"url\",\r\n        },\r\n      ]) ?? (generator?.url ?? $generator.url)(),\r\n    ip: $pick([\r\n      () =>\r\n        (generator?.customs ?? $generator.customs)?.string?.([\r\n          {\r\n            name: 'Format<\"ipv4\">',\r\n            kind: \"format\",\r\n            value: \"ipv4\",\r\n          },\r\n        ]) ?? (generator?.ipv4 ?? $generator.ipv4)(),\r\n      () =>\r\n        (generator?.customs ?? $generator.customs)?.string?.([\r\n          {\r\n            name: 'Format<\"ipv6\">',\r\n            kind: \"format\",\r\n            value: \"ipv6\",\r\n          },\r\n        ]) ?? (generator?.ipv6 ?? $generator.ipv6)(),\r\n    ])(),\r\n    time:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"date-time\">',\r\n          kind: \"format\",\r\n          value: \"date-time\",\r\n        },\r\n      ]) ?? (generator?.datetime ?? $generator.datetime)(),\r\n  });\r\n  return $ro0();\r\n})();\r\nconst encoded = ((input) => {\r\n  const $throws = typia_1.default.protobuf.encode.throws;\r\n  const $Sizer = typia_1.default.protobuf.encode.Sizer;\r\n  const $Writer = typia_1.default.protobuf.encode.Writer;\r\n  const encoder = (writer) => {\r\n    const $peo0 = (input) => {\r\n      // property \"id\";\r\n      writer.uint32(8);\r\n      writer.int32(input.id);\r\n      // property \"email\";\r\n      writer.uint32(18);\r\n      writer.string(input.email);\r\n      // property \"name\";\r\n      writer.uint32(26);\r\n      writer.string(input.name);\r\n      // property \"pet\";\r\n      if (null !== input.pet) {\r\n        if (\"cat\" === input.pet.type)\r\n          (() => {\r\n            // 4 -> ICat;\r\n            writer.uint32(34);\r\n            writer.fork();\r\n            $peo1(input.pet);\r\n            writer.ldelim();\r\n          })();\r\n        else if (\"dog\" === input.pet.type)\r\n          (() => {\r\n            // 5 -> IDog;\r\n            writer.uint32(42);\r\n            writer.fork();\r\n            $peo2(input.pet);\r\n            writer.ldelim();\r\n          })();\r\n        else\r\n          $throws({\r\n            expected: \"(ICat | IDog)\",\r\n            value: input.pet,\r\n          });\r\n      }\r\n      // property \"memo\";\r\n      if (null !== input.memo) {\r\n        for (const [key, value] of input.memo) {\r\n          writer.uint32(50);\r\n          writer.fork();\r\n          writer.uint32(10);\r\n          writer.string(key);\r\n          writer.uint32(18);\r\n          writer.string(value);\r\n          writer.ldelim();\r\n        }\r\n      }\r\n      // property \"logins\";\r\n      if (0 !== input.logins.length) {\r\n        for (const elem of input.logins) {\r\n          // 7 -> ICustomerLogin;\r\n          writer.uint32(58);\r\n          writer.fork();\r\n          $peo3(elem);\r\n          writer.ldelim();\r\n        }\r\n      }\r\n    };\r\n    const $peo1 = (input) => {\r\n      // property \"type\";\r\n      writer.uint32(10);\r\n      writer.string(input.type);\r\n      // property \"name\";\r\n      writer.uint32(18);\r\n      writer.string(input.name);\r\n      // property \"ribbon\";\r\n      writer.uint32(24);\r\n      writer.bool(input.ribbon);\r\n    };\r\n    const $peo2 = (input) => {\r\n      // property \"type\";\r\n      writer.uint32(10);\r\n      writer.string(input.type);\r\n      // property \"name\";\r\n      writer.uint32(18);\r\n      writer.string(input.name);\r\n      // property \"hunt\";\r\n      writer.uint32(24);\r\n      writer.bool(input.hunt);\r\n    };\r\n    const $peo3 = (input) => {\r\n      // property \"success\";\r\n      writer.uint32(8);\r\n      writer.bool(input.success);\r\n      // property \"href\";\r\n      writer.uint32(18);\r\n      writer.string(input.href);\r\n      // property \"referrer\";\r\n      writer.uint32(26);\r\n      writer.string(input.referrer);\r\n      // property \"ip\";\r\n      writer.uint32(34);\r\n      writer.string(input.ip);\r\n      // property \"time\";\r\n      writer.uint32(42);\r\n      writer.string(input.time);\r\n    };\r\n    const $io1 = (input) =>\r\n      \"cat\" === input.type &&\r\n      \"string\" === typeof input.name &&\r\n      \"boolean\" === typeof input.ribbon;\r\n    const $io2 = (input) =>\r\n      \"dog\" === input.type &&\r\n      \"string\" === typeof input.name &&\r\n      \"boolean\" === typeof input.hunt;\r\n    const $io3 = (input) =>\r\n      \"boolean\" === typeof input.success &&\r\n      \"string\" === typeof input.href &&\r\n      /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n        input.href,\r\n      ) &&\r\n      \"string\" === typeof input.referrer &&\r\n      /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n        input.referrer,\r\n      ) &&\r\n      \"string\" === typeof input.ip &&\r\n      (/^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/.test(\r\n        input.ip,\r\n      ) ||\r\n        /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))$/i.test(\r\n          input.ip,\r\n        )) &&\r\n      \"string\" === typeof input.time &&\r\n      !isNaN(new Date(input.time).getTime());\r\n    const $iu0 = (input) =>\r\n      (() => {\r\n        if (\"cat\" === input.type) return $io1(input);\r\n        else if (\"dog\" === input.type) return $io2(input);\r\n        else return false;\r\n      })();\r\n    //ICustomer;\r\n    $peo0(input);\r\n    return writer;\r\n  };\r\n  const sizer = encoder(new $Sizer());\r\n  const writer = encoder(new $Writer(sizer));\r\n  return writer.buffer();\r\n})(data);\r\n((input) => {\r\n  const $Reader = typia_1.default.protobuf.decode.Reader;\r\n  const $pdo0 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      id: undefined,\r\n      email: \"\",\r\n      name: \"\",\r\n      pet: null,\r\n      memo: null,\r\n      logins: [],\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // int32;\r\n          output.id = reader.int32();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.email = reader.string();\r\n          break;\r\n        case 3:\r\n          // string;\r\n          output.name = reader.string();\r\n          break;\r\n        case 4:\r\n          // ICat;\r\n          output.pet = $pdo1(reader, reader.uint32());\r\n          break;\r\n        case 5:\r\n          // IDog;\r\n          output.pet = $pdo2(reader, reader.uint32());\r\n          break;\r\n        case 6:\r\n          // type: Map<string, string>;\r\n          (() => {\r\n            output.memo ??= new Map();\r\n            const piece = reader.uint32() + reader.index();\r\n            const entry = {\r\n              key: \"\",\r\n              value: \"\",\r\n            };\r\n            while (reader.index() < piece) {\r\n              const kind = reader.uint32();\r\n              switch (kind >>> 3) {\r\n                case 1:\r\n                  // string;\r\n                  entry.key = reader.string();\r\n                  break;\r\n                case 2:\r\n                  // string;\r\n                  entry.value = reader.string();\r\n                  break;\r\n                default:\r\n                  reader.skipType(kind & 7);\r\n                  break;\r\n              }\r\n            }\r\n            output.memo.set(entry.key, entry.value);\r\n          })();\r\n          break;\r\n        case 7:\r\n          // type: Array<ICustomerLogin>;\r\n          output.logins.push($pdo3(reader, reader.uint32()));\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const $pdo1 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      type: undefined,\r\n      name: \"\",\r\n      ribbon: undefined,\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // string;\r\n          output.type = reader.string();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.name = reader.string();\r\n          break;\r\n        case 3:\r\n          // bool;\r\n          output.ribbon = reader.bool();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const $pdo2 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      type: undefined,\r\n      name: \"\",\r\n      hunt: undefined,\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // string;\r\n          output.type = reader.string();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.name = reader.string();\r\n          break;\r\n        case 3:\r\n          // bool;\r\n          output.hunt = reader.bool();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const $pdo3 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      success: undefined,\r\n      href: \"\",\r\n      referrer: \"\",\r\n      ip: \"\",\r\n      time: \"\",\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // bool;\r\n          output.success = reader.bool();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.href = reader.string();\r\n          break;\r\n        case 3:\r\n          // string;\r\n          output.referrer = reader.string();\r\n          break;\r\n        case 4:\r\n          // string;\r\n          output.ip = reader.string();\r\n          break;\r\n        case 5:\r\n          // string;\r\n          output.time = reader.string();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const reader = new $Reader(input);\r\n  return $pdo0(reader);\r\n})(encoded);","reusable-functions#Reusable functions":"export namespace protobuf {\r\n  export function createDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\r\n  export function createIsDecode<T>: (buffer: Uint8Array) => Resolved<T> | null;\r\n  export function createAssertDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\r\n  export function createValidateDecode<T>(): (\r\n      buffer: Uint8Array\r\n  ) => IValidation<Resolved<T>>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\ninterface ICustomer {\r\n  id: number & tags.Type<\"int32\">;\r\n  email: string & tags.Format<\"email\">;\r\n  name: string;\r\n  pet: null | ICat | IDog;\r\n  memo: null | Map<string, string>;\r\n  logins: Array<ICustomerLogin>;\r\n}\r\ninterface ICat {\r\n  type: \"cat\";\r\n  name: string;\r\n  ribbon: boolean;\r\n}\r\ninterface IDog {\r\n  type: \"dog\";\r\n  name: string;\r\n  hunt: boolean;\r\n}\r\ninterface ICustomerLogin {\r\n  success: boolean;\r\n  href: string & tags.Format<\"url\">;\r\n  referrer: string & tags.Format<\"url\">;\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  time: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nconst data: ICustomer = typia.random<ICustomer>();\r\nconst encoded: Uint8Array = typia.protobuf.encode(data);\r\ntypia.protobuf.decode<ICustomer>(encoded);\nReusable typia.protobuf.decode<T>() function generators.If you repeat to call typia.protobuf.decode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createDecode<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const encode = typia.protobuf.createDecode<ICustomer>();\r\n\r\ninterface ICustomer {\r\n  id: number & tags.Type<\"int32\">;\r\n  email: string & tags.Format<\"email\">;\r\n  name: string;\r\n  pet: null | ICat | IDog;\r\n  memo: null | Map<string, string>;\r\n  logins: Array<ICustomerLogin>;\r\n}\r\ninterface ICat {\r\n  type: \"cat\";\r\n  name: string;\r\n  ribbon: boolean;\r\n}\r\ninterface IDog {\r\n  type: \"dog\";\r\n  name: string;\r\n  hunt: boolean;\r\n}\r\ninterface ICustomerLogin {\r\n  success: boolean;\r\n  href: string & tags.Format<\"url\">;\r\n  referrer: string & tags.Format<\"url\">;\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  time: string & tags.Format<\"date-time\">;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.encode = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst encode = (input) => {\r\n  const $Reader = typia_1.default.protobuf.createDecode.Reader;\r\n  const $pdo0 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      id: undefined,\r\n      email: \"\",\r\n      name: \"\",\r\n      pet: null,\r\n      memo: null,\r\n      logins: [],\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // int32;\r\n          output.id = reader.int32();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.email = reader.string();\r\n          break;\r\n        case 3:\r\n          // string;\r\n          output.name = reader.string();\r\n          break;\r\n        case 4:\r\n          // ICat;\r\n          output.pet = $pdo1(reader, reader.uint32());\r\n          break;\r\n        case 5:\r\n          // IDog;\r\n          output.pet = $pdo2(reader, reader.uint32());\r\n          break;\r\n        case 6:\r\n          // type: Map<string, string>;\r\n          (() => {\r\n            output.memo ??= new Map();\r\n            const piece = reader.uint32() + reader.index();\r\n            const entry = {\r\n              key: \"\",\r\n              value: \"\",\r\n            };\r\n            while (reader.index() < piece) {\r\n              const kind = reader.uint32();\r\n              switch (kind >>> 3) {\r\n                case 1:\r\n                  // string;\r\n                  entry.key = reader.string();\r\n                  break;\r\n                case 2:\r\n                  // string;\r\n                  entry.value = reader.string();\r\n                  break;\r\n                default:\r\n                  reader.skipType(kind & 7);\r\n                  break;\r\n              }\r\n            }\r\n            output.memo.set(entry.key, entry.value);\r\n          })();\r\n          break;\r\n        case 7:\r\n          // type: Array<ICustomerLogin>;\r\n          output.logins.push($pdo3(reader, reader.uint32()));\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const $pdo1 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      type: undefined,\r\n      name: \"\",\r\n      ribbon: undefined,\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // string;\r\n          output.type = reader.string();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.name = reader.string();\r\n          break;\r\n        case 3:\r\n          // bool;\r\n          output.ribbon = reader.bool();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const $pdo2 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      type: undefined,\r\n      name: \"\",\r\n      hunt: undefined,\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // string;\r\n          output.type = reader.string();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.name = reader.string();\r\n          break;\r\n        case 3:\r\n          // bool;\r\n          output.hunt = reader.bool();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const $pdo3 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      success: undefined,\r\n      href: \"\",\r\n      referrer: \"\",\r\n      ip: \"\",\r\n      time: \"\",\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // bool;\r\n          output.success = reader.bool();\r\n          break;\r\n        case 2:\r\n          // string;\r\n          output.href = reader.string();\r\n          break;\r\n        case 3:\r\n          // string;\r\n          output.referrer = reader.string();\r\n          break;\r\n        case 4:\r\n          // string;\r\n          output.ip = reader.string();\r\n          break;\r\n        case 5:\r\n          // string;\r\n          output.time = reader.string();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const reader = new $Reader(input);\r\n  return $pdo0(reader);\r\n};\r\nexports.encode = encode;","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.decode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/protobuf/encode":{"title":"Encode","data":{"encode-functions#encode() functions":"export namespace protobuf {\r\n  export function encode<T>(input: T): Uint8Array;\r\n  export function isEncode<T>(input: T): Uint8Array | null;\r\n  export function assertEncode<T>(input: T): Uint8Array;\r\n  export function validateEncode<T>(input: T): IValidation<Uint8Array>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nProtocol Buffer Encoder.You can easily convert a JavaScript object to a binary data of Protocol Buffer, without any extra Protocol Buffer Message Schema definition. typia.protobuf.encode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally. And then, it converts the input instance to the binary data of Protocol Buffer format.By the way, typia.protobuf.encode<T>() function does not validate the input value. It just believes user and input value, and converts to the Protocol Buffer binary data directly without any validation. By the way, if the input value was not validate, the encoded binary data never can be decoded. So, if you can't sure the input value type, you should use below functions instead.\ntypia.protobuf.isEncode<T>(): typia.is<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.assertEncode<T>(): typia.assert<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.validateEncode<T>(): typia.validate<T>() + typia.protobuf.encode<T>()\nAOT compliation\ntypia.protobuf.encode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\nimport typia, { tags } from \"typia\";\r\n\r\ninterface ICustomer {\r\n  id: number & tags.Type<\"int32\">;\r\n  email: string & tags.Format<\"email\">;\r\n  name: string;\r\n  pet: null | ICat | IDog;\r\n  memo: null | Map<string, string>;\r\n  logins: Array<ICustomerLogin>;\r\n}\r\ninterface ICat {\r\n  type: \"cat\";\r\n  name: string;\r\n  ribbon: boolean;\r\n}\r\ninterface IDog {\r\n  type: \"dog\";\r\n  name: string;\r\n  hunt: boolean;\r\n}\r\ninterface ICustomerLogin {\r\n  success: boolean;\r\n  href: string & tags.Format<\"url\">;\r\n  referrer: string & tags.Format<\"url\">;\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  time: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nconst customer: ICustomer = typia.random<ICustomer>();\r\ntypia.protobuf.encode<ICustomer>(customer);\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst customer = ((generator) => {\r\n  const $generator = typia_1.default.random.generator;\r\n  const $pick = typia_1.default.random.pick;\r\n  const $ro0 = (_recursive = false, _depth = 0) => ({\r\n    id:\r\n      (generator?.customs ?? $generator.customs)?.number?.([\r\n        {\r\n          name: 'Type<\"int32\">',\r\n          kind: \"type\",\r\n          value: \"int32\",\r\n        },\r\n      ]) ?? (generator?.integer ?? $generator.integer)(0, 100),\r\n    email:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"email\">',\r\n          kind: \"format\",\r\n          value: \"email\",\r\n        },\r\n      ]) ?? (generator?.email ?? $generator.email)(),\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n      (generator?.string ?? $generator.string)(),\r\n    pet: $pick([\r\n      () => null,\r\n      () => $ro1(_recursive, _recursive ? 1 + _depth : _depth),\r\n      () => $ro2(_recursive, _recursive ? 1 + _depth : _depth),\r\n    ])(),\r\n    memo: $pick([\r\n      () => null,\r\n      () =>\r\n        new Map(\r\n          (generator?.array ?? $generator.array)(() => [\r\n            (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n              (generator?.string ?? $generator.string)(),\r\n            (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n              (generator?.string ?? $generator.string)(),\r\n          ]),\r\n        ),\r\n    ])(),\r\n    logins: (generator?.array ?? $generator.array)(() =>\r\n      $ro3(_recursive, _recursive ? 1 + _depth : _depth),\r\n    ),\r\n  });\r\n  const $ro1 = (_recursive = false, _depth = 0) => ({\r\n    type: \"cat\",\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n      (generator?.string ?? $generator.string)(),\r\n    ribbon: (generator?.boolean ?? $generator.boolean)(),\r\n  });\r\n  const $ro2 = (_recursive = false, _depth = 0) => ({\r\n    type: \"dog\",\r\n    name:\r\n      (generator?.customs ?? $generator.customs)?.string?.([]) ??\r\n      (generator?.string ?? $generator.string)(),\r\n    hunt: (generator?.boolean ?? $generator.boolean)(),\r\n  });\r\n  const $ro3 = (_recursive = false, _depth = 0) => ({\r\n    success: (generator?.boolean ?? $generator.boolean)(),\r\n    href:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"url\">',\r\n          kind: \"format\",\r\n          value: \"url\",\r\n        },\r\n      ]) ?? (generator?.url ?? $generator.url)(),\r\n    referrer:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"url\">',\r\n          kind: \"format\",\r\n          value: \"url\",\r\n        },\r\n      ]) ?? (generator?.url ?? $generator.url)(),\r\n    ip: $pick([\r\n      () =>\r\n        (generator?.customs ?? $generator.customs)?.string?.([\r\n          {\r\n            name: 'Format<\"ipv4\">',\r\n            kind: \"format\",\r\n            value: \"ipv4\",\r\n          },\r\n        ]) ?? (generator?.ipv4 ?? $generator.ipv4)(),\r\n      () =>\r\n        (generator?.customs ?? $generator.customs)?.string?.([\r\n          {\r\n            name: 'Format<\"ipv6\">',\r\n            kind: \"format\",\r\n            value: \"ipv6\",\r\n          },\r\n        ]) ?? (generator?.ipv6 ?? $generator.ipv6)(),\r\n    ])(),\r\n    time:\r\n      (generator?.customs ?? $generator.customs)?.string?.([\r\n        {\r\n          name: 'Format<\"date-time\">',\r\n          kind: \"format\",\r\n          value: \"date-time\",\r\n        },\r\n      ]) ?? (generator?.datetime ?? $generator.datetime)(),\r\n  });\r\n  return $ro0();\r\n})();\r\n((input) => {\r\n  const $throws = typia_1.default.protobuf.encode.throws;\r\n  const $Sizer = typia_1.default.protobuf.encode.Sizer;\r\n  const $Writer = typia_1.default.protobuf.encode.Writer;\r\n  const encoder = (writer) => {\r\n    const $peo0 = (input) => {\r\n      // property \"id\";\r\n      writer.uint32(8);\r\n      writer.int32(input.id);\r\n      // property \"email\";\r\n      writer.uint32(18);\r\n      writer.string(input.email);\r\n      // property \"name\";\r\n      writer.uint32(26);\r\n      writer.string(input.name);\r\n      // property \"pet\";\r\n      if (null !== input.pet) {\r\n        if (\"cat\" === input.pet.type)\r\n          (() => {\r\n            // 4 -> ICat;\r\n            writer.uint32(34);\r\n            writer.fork();\r\n            $peo1(input.pet);\r\n            writer.ldelim();\r\n          })();\r\n        else if (\"dog\" === input.pet.type)\r\n          (() => {\r\n            // 5 -> IDog;\r\n            writer.uint32(42);\r\n            writer.fork();\r\n            $peo2(input.pet);\r\n            writer.ldelim();\r\n          })();\r\n        else\r\n          $throws({\r\n            expected: \"(ICat | IDog)\",\r\n            value: input.pet,\r\n          });\r\n      }\r\n      // property \"memo\";\r\n      if (null !== input.memo) {\r\n        for (const [key, value] of input.memo) {\r\n          writer.uint32(50);\r\n          writer.fork();\r\n          writer.uint32(10);\r\n          writer.string(key);\r\n          writer.uint32(18);\r\n          writer.string(value);\r\n          writer.ldelim();\r\n        }\r\n      }\r\n      // property \"logins\";\r\n      if (0 !== input.logins.length) {\r\n        for (const elem of input.logins) {\r\n          // 7 -> ICustomerLogin;\r\n          writer.uint32(58);\r\n          writer.fork();\r\n          $peo3(elem);\r\n          writer.ldelim();\r\n        }\r\n      }\r\n    };\r\n    const $peo1 = (input) => {\r\n      // property \"type\";\r\n      writer.uint32(10);\r\n      writer.string(input.type);\r\n      // property \"name\";\r\n      writer.uint32(18);\r\n      writer.string(input.name);\r\n      // property \"ribbon\";\r\n      writer.uint32(24);\r\n      writer.bool(input.ribbon);\r\n    };\r\n    const $peo2 = (input) => {\r\n      // property \"type\";\r\n      writer.uint32(10);\r\n      writer.string(input.type);\r\n      // property \"name\";\r\n      writer.uint32(18);\r\n      writer.string(input.name);\r\n      // property \"hunt\";\r\n      writer.uint32(24);\r\n      writer.bool(input.hunt);\r\n    };\r\n    const $peo3 = (input) => {\r\n      // property \"success\";\r\n      writer.uint32(8);\r\n      writer.bool(input.success);\r\n      // property \"href\";\r\n      writer.uint32(18);\r\n      writer.string(input.href);\r\n      // property \"referrer\";\r\n      writer.uint32(26);\r\n      writer.string(input.referrer);\r\n      // property \"ip\";\r\n      writer.uint32(34);\r\n      writer.string(input.ip);\r\n      // property \"time\";\r\n      writer.uint32(42);\r\n      writer.string(input.time);\r\n    };\r\n    const $io1 = (input) =>\r\n      \"cat\" === input.type &&\r\n      \"string\" === typeof input.name &&\r\n      \"boolean\" === typeof input.ribbon;\r\n    const $io2 = (input) =>\r\n      \"dog\" === input.type &&\r\n      \"string\" === typeof input.name &&\r\n      \"boolean\" === typeof input.hunt;\r\n    const $io3 = (input) =>\r\n      \"boolean\" === typeof input.success &&\r\n      \"string\" === typeof input.href &&\r\n      /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n        input.href,\r\n      ) &&\r\n      \"string\" === typeof input.referrer &&\r\n      /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n        input.referrer,\r\n      ) &&\r\n      \"string\" === typeof input.ip &&\r\n      (/^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/.test(\r\n        input.ip,\r\n      ) ||\r\n        /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))$/i.test(\r\n          input.ip,\r\n        )) &&\r\n      \"string\" === typeof input.time &&\r\n      !isNaN(new Date(input.time).getTime());\r\n    const $iu0 = (input) =>\r\n      (() => {\r\n        if (\"cat\" === input.type) return $io1(input);\r\n        else if (\"dog\" === input.type) return $io2(input);\r\n        else return false;\r\n      })();\r\n    //ICustomer;\r\n    $peo0(input);\r\n    return writer;\r\n  };\r\n  const sizer = encoder(new $Sizer());\r\n  const writer = encoder(new $Writer(sizer));\r\n  return writer.buffer();\r\n})(customer);\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}","reusable-functions#Reusable Functions":"export namespace protobuf {\r\n  export function encode<T>(): (input: T) => Uint8Array;\r\n  export function isEncode<T>(): (input: T) => Uint8Array | null;\r\n  export function assertEncode<T>(): (input: T) => Uint8Array;\r\n  export function validateEncode<T>(): (input: T) => IValidation<Uint8Array>;\r\n}\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\n/**\r\n * Resolved type erased every methods.\r\n *\r\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\r\n * its argument as a resolved type that erased every method properties.\r\n *\r\n * If the target argument is a built-in class which returns its origin primitive type\r\n * through the `valueOf()` method like the `String` or `Number`, its return type would\r\n * be the `string` or `number`. Otherwise, the built-in class does not have the\r\n * `valueOf()` method, the return type would be same with the target argument.\r\n *\r\n * Otherwise, the target argument is a type of custom class, all of its custom methods\r\n * would be erased and its prototype would be changed to the primitive `object`.\r\n * Therefore, return type of the TMP type finally be the resolved object.\r\n *\r\n * Before                  | After\r\n * ------------------------|----------------------------------------\r\n * `Boolean`               | `boolean`\r\n * `Number`                | `number`\r\n * `BigInt`                | `bigint`\r\n * `String`                | `string`\r\n * `Class`                 | `interface`\r\n * Native Class or Others  | No change\r\n *\r\n * @template T Target argument type.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n * @author Kyungsu Kang - https://github.com/kakasoo\r\n */\r\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\r\n  ? T\r\n  : ResolvedMain<T>;\r\n\r\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\r\n\r\ntype ResolvedMain<T> = T extends [never]\r\n  ? never // (special trick for jsonable | null) type\r\n  : ValueOf<T> extends boolean | number | bigint | string\r\n  ? ValueOf<T>\r\n  : T extends Function\r\n  ? never\r\n  : T extends object\r\n  ? ResolvedObject<T>\r\n  : ValueOf<T>;\r\n\r\ntype ResolvedObject<T extends object> = T extends Array<infer U>\r\n  ? IsTuple<T> extends true\r\n    ? ResolvedTuple<T>\r\n    : ResolvedMain<U>[]\r\n  : T extends Set<infer U>\r\n  ? Set<ResolvedMain<U>>\r\n  : T extends Map<infer K, infer V>\r\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\r\n  : T extends WeakSet<any> | WeakMap<any, any>\r\n  ? never\r\n  : T extends\r\n      | Date\r\n      | Uint8Array\r\n      | Uint8ClampedArray\r\n      | Uint16Array\r\n      | Uint32Array\r\n      | BigUint64Array\r\n      | Int8Array\r\n      | Int16Array\r\n      | Int32Array\r\n      | BigInt64Array\r\n      | Float32Array\r\n      | Float64Array\r\n      | ArrayBuffer\r\n      | SharedArrayBuffer\r\n      | DataView\r\n      | Blob\r\n      | File\r\n  ? T\r\n  : {\r\n      [P in keyof T]: ResolvedMain<T[P]>;\r\n    };\r\n\r\ntype ResolvedTuple<T extends readonly any[]> = T extends []\r\n  ? []\r\n  : T extends [infer F]\r\n  ? [ResolvedMain<F>]\r\n  : T extends [infer F, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\r\n  : T extends [(infer F)?]\r\n  ? [ResolvedMain<F>?]\r\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\r\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\r\n  : [];\r\n\r\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\r\n  never,\r\n]\r\n  ? false\r\n  : T extends readonly any[]\r\n  ? number extends T[\"length\"]\r\n    ? false\r\n    : true\r\n  : false;\r\n\r\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\r\n  ? boolean\r\n  : IsValueOf<Instance, Number> extends true\r\n  ? number\r\n  : IsValueOf<Instance, String> extends true\r\n  ? string\r\n  : Instance;\r\n\r\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\r\n  ? Object extends IValueOf<infer Primitive>\r\n    ? Instance extends Primitive\r\n      ? false\r\n      : true // not Primitive, but Object\r\n    : false // cannot be\r\n  : false;\r\n\r\ninterface IValueOf<T> {\r\n  valueOf(): T;\r\n}\nReusable typia.protobuf.encode<T>() function generators.If you repeat to call typia.protobuf.encode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createEncode<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const encode = typia.protobuf.createEncode<ICustomer>();\r\n\r\ninterface ICustomer {\r\n  id: number & tags.Type<\"int32\">;\r\n  email: string & tags.Format<\"email\">;\r\n  name: string;\r\n  pet: null | ICat | IDog;\r\n  memo: null | Map<string, string>;\r\n  logins: Array<ICustomerLogin>;\r\n}\r\ninterface ICat {\r\n  type: \"cat\";\r\n  name: string;\r\n  ribbon: boolean;\r\n}\r\ninterface IDog {\r\n  type: \"dog\";\r\n  name: string;\r\n  hunt: boolean;\r\n}\r\ninterface ICustomerLogin {\r\n  success: boolean;\r\n  href: string & tags.Format<\"url\">;\r\n  referrer: string & tags.Format<\"url\">;\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  time: string & tags.Format<\"date-time\">;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.encode = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst encode = (input) => {\r\n  const $throws = typia_1.default.protobuf.createEncode.throws;\r\n  const $Sizer = typia_1.default.protobuf.createEncode.Sizer;\r\n  const $Writer = typia_1.default.protobuf.createEncode.Writer;\r\n  const encoder = (writer) => {\r\n    const $peo0 = (input) => {\r\n      // property \"id\";\r\n      writer.uint32(8);\r\n      writer.int32(input.id);\r\n      // property \"email\";\r\n      writer.uint32(18);\r\n      writer.string(input.email);\r\n      // property \"name\";\r\n      writer.uint32(26);\r\n      writer.string(input.name);\r\n      // property \"pet\";\r\n      if (null !== input.pet) {\r\n        if (\"cat\" === input.pet.type)\r\n          (() => {\r\n            // 4 -> ICat;\r\n            writer.uint32(34);\r\n            writer.fork();\r\n            $peo1(input.pet);\r\n            writer.ldelim();\r\n          })();\r\n        else if (\"dog\" === input.pet.type)\r\n          (() => {\r\n            // 5 -> IDog;\r\n            writer.uint32(42);\r\n            writer.fork();\r\n            $peo2(input.pet);\r\n            writer.ldelim();\r\n          })();\r\n        else\r\n          $throws({\r\n            expected: \"(ICat | IDog)\",\r\n            value: input.pet,\r\n          });\r\n      }\r\n      // property \"memo\";\r\n      if (null !== input.memo) {\r\n        for (const [key, value] of input.memo) {\r\n          writer.uint32(50);\r\n          writer.fork();\r\n          writer.uint32(10);\r\n          writer.string(key);\r\n          writer.uint32(18);\r\n          writer.string(value);\r\n          writer.ldelim();\r\n        }\r\n      }\r\n      // property \"logins\";\r\n      if (0 !== input.logins.length) {\r\n        for (const elem of input.logins) {\r\n          // 7 -> ICustomerLogin;\r\n          writer.uint32(58);\r\n          writer.fork();\r\n          $peo3(elem);\r\n          writer.ldelim();\r\n        }\r\n      }\r\n    };\r\n    const $peo1 = (input) => {\r\n      // property \"type\";\r\n      writer.uint32(10);\r\n      writer.string(input.type);\r\n      // property \"name\";\r\n      writer.uint32(18);\r\n      writer.string(input.name);\r\n      // property \"ribbon\";\r\n      writer.uint32(24);\r\n      writer.bool(input.ribbon);\r\n    };\r\n    const $peo2 = (input) => {\r\n      // property \"type\";\r\n      writer.uint32(10);\r\n      writer.string(input.type);\r\n      // property \"name\";\r\n      writer.uint32(18);\r\n      writer.string(input.name);\r\n      // property \"hunt\";\r\n      writer.uint32(24);\r\n      writer.bool(input.hunt);\r\n    };\r\n    const $peo3 = (input) => {\r\n      // property \"success\";\r\n      writer.uint32(8);\r\n      writer.bool(input.success);\r\n      // property \"href\";\r\n      writer.uint32(18);\r\n      writer.string(input.href);\r\n      // property \"referrer\";\r\n      writer.uint32(26);\r\n      writer.string(input.referrer);\r\n      // property \"ip\";\r\n      writer.uint32(34);\r\n      writer.string(input.ip);\r\n      // property \"time\";\r\n      writer.uint32(42);\r\n      writer.string(input.time);\r\n    };\r\n    const $io1 = (input) =>\r\n      \"cat\" === input.type &&\r\n      \"string\" === typeof input.name &&\r\n      \"boolean\" === typeof input.ribbon;\r\n    const $io2 = (input) =>\r\n      \"dog\" === input.type &&\r\n      \"string\" === typeof input.name &&\r\n      \"boolean\" === typeof input.hunt;\r\n    const $io3 = (input) =>\r\n      \"boolean\" === typeof input.success &&\r\n      \"string\" === typeof input.href &&\r\n      /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n        input.href,\r\n      ) &&\r\n      \"string\" === typeof input.referrer &&\r\n      /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n        input.referrer,\r\n      ) &&\r\n      \"string\" === typeof input.ip &&\r\n      (/^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/.test(\r\n        input.ip,\r\n      ) ||\r\n        /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))$/i.test(\r\n          input.ip,\r\n        )) &&\r\n      \"string\" === typeof input.time &&\r\n      !isNaN(new Date(input.time).getTime());\r\n    const $iu0 = (input) =>\r\n      (() => {\r\n        if (\"cat\" === input.type) return $io1(input);\r\n        else if (\"dog\" === input.type) return $io2(input);\r\n        else return false;\r\n      })();\r\n    //ICustomer;\r\n    $peo0(input);\r\n    return writer;\r\n  };\r\n  const sizer = encoder(new $Sizer());\r\n  const writer = encoder(new $Writer(sizer));\r\n  return writer.buffer();\r\n};\r\nexports.encode = encode;","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.encode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/protobuf/message":{"title":"Message","data":{"message-function#message() function":"export namespace protobuf {\r\n  export function message<T>(): string;\r\n}\ntypia.protobuf.message() function returns a Protocol Buffer message (structure) as a string value.With this message() function, you can share *.proto files with other languages. If you want to customize byte order or define specific type (that is not supported in the TypeScript) like uint32, use comment tags by following comment tags section.\nimport typia, { tags } from \"typia\";\r\n\r\ninterface ICustomer {\r\n  id: number & tags.Type<\"int32\">;\r\n  email: string & tags.Format<\"email\">;\r\n  name: string;\r\n  pet: null | ICat | IDog;\r\n  memo: null | Map<string, string>;\r\n  logins: Array<ICustomerLogin>;\r\n}\r\ninterface ICat {\r\n  type: \"cat\";\r\n  name: string;\r\n  ribbon: boolean;\r\n}\r\ninterface IDog {\r\n  type: \"dog\";\r\n  name: string;\r\n  hunt: boolean;\r\n}\r\ninterface ICustomerLogin {\r\n  success: boolean;\r\n  href: string & tags.Format<\"url\">;\r\n  referrer: string & tags.Format<\"url\">;\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  time: string & tags.Format<\"date-time\">;\r\n}\r\n\r\ntypia.protobuf.message<ICustomer>();\nsyntax = \"proto3\";\r\n\r\nmessage ICustomer {\r\n  required int32 id = 1;\r\n  required string email = 2;\r\n  required string name = 3;\r\n  oneof pet {\r\n    ICat v4 = 4;\r\n    IDog v5 = 5;\r\n  }\r\n  map<string, string> memo = 6;\r\n  repeated ICustomerLogin logins = 7;\r\n}\r\n\r\nmessage ICat {\r\n  required string type = 1;\r\n  required string name = 2;\r\n  required bool ribbon = 3;\r\n}\r\n\r\nmessage IDog {\r\n  required string type = 1;\r\n  required string name = 2;\r\n  required bool hunt = 3;\r\n}\r\n\r\nmessage ICustomerLogin {\r\n  required bool success = 1;\r\n  required string href = 2;\r\n  required string referrer = 3;\r\n  required string ip = 4;\r\n  required string time = 5;\r\n}","type-tags#Type Tags":"By using type tags, you can use special numeric types that are not supported in the TypeScript.Just import Type (or typia.tags.Type) type, and combine it with number or bigint type through intersection symbol number & typia.tagsType<\"float\"> case. If you want to declare an union numeric type, combine | and bracket (()) symbols properly like below.When you take a mistake that choosing different target type, TypeScript compiler would block it with compliation error message. Therefore, have a confidence when using the Type tag. For such type safety reason, I recommend to use Type tag instead of using comment tags as much as possible.\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64\nimport typia, { tags } from \"typia\";\r\n\r\nexport interface TypeTagExample {\r\n  // ATOMIC TYPES\r\n  int32: number & tags.Type<\"int32\">;\r\n  uint32: number & tags.Type<\"uint32\">;\r\n  uint64: bigint & tags.Type<\"uint64\">;\r\n  int64: number & tags.Type<\"int64\">;\r\n  float: number & tags.Type<\"float\">;\r\n  double: number | undefined;\r\n  string: string | null;\r\n\r\n  // UNION TYPES\r\n  uint32_or_double: number & (tags.Type<\"uint32\"> | tags.Type<\"double\">);\r\n  int32_or_uint64:\r\n    | (number & tags.Type<\"int32\">)\r\n    | (bigint & tags.Type<\"uint64\">);\r\n  int32_or_float_or_uint64:\r\n    | (number & (tags.Type<\"int32\"> | tags.Type<\"float\">))\r\n    | (bigint & tags.Type<\"uint64\">);\r\n\r\n  // ARRAY AND MAP\r\n  uint64_array: Array<bigint & tags.Type<\"uint64\">>;\r\n  int32_map?: Map<number & tags.Type<\"int32\">, string> | null;\r\n}\r\n\r\n//----\r\n// PROTOBUF MESSAGE SCHEMA\r\n//----\r\ntypia.protobuf.message<TypeTagExample>();\r\n\r\n//----\r\n// DECODE FUNCTION\r\n//----\r\ntypia.protobuf.createDecode<TypeTagExample>();\r\n\r\n//----\r\n// ENCODE FUNCTION\r\n//----\r\ntypia.protobuf.createEncode<TypeTagExample>();\nsyntax = \"proto3\";\r\n\r\nmessage TypeTagExample {\r\n  required int32 int32 = 1;\r\n  required uint32 uint32 = 2;\r\n  required uint64 uint64 = 3;\r\n  required int64 int64 = 4;\r\n  required float float = 5;\r\n  optional double double = 6;\r\n  optional string string = 7;\r\n  oneof uint32_or_double {\r\n    uint32 v8 = 8;\r\n    double v9 = 9;\r\n  }\r\n  oneof int32_or_uint64 {\r\n    int32 v10 = 10;\r\n    uint64 v11 = 11;\r\n  }\r\n  oneof int32_or_float_or_uint64 {\r\n    int32 v12 = 12;\r\n    uint64 v13 = 13;\r\n    float v14 = 14;\r\n  }\r\n  repeated uint64 uint64_array = 15;\r\n  map<int32, string> int32_map = 16;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n//----\r\n// PROTOBUF MESSAGE SCHEMA\r\n//----\r\n('syntax = \"proto3\";\\n\\nmessage TypeTagExample {\\n    required int32 int32 = 1;\\n    required uint32 uint32 = 2;\\n    required uint64 uint64 = 3;\\n    required int64 int64 = 4;\\n    required float float = 5;\\n    optional double double = 6;\\n    optional string string = 7;\\n    oneof uint32_or_double {\\n        uint32 v8 = 8;\\n        double v9 = 9;\\n    }\\n    oneof int32_or_uint64 {\\n        int32 v10 = 10;\\n        uint64 v11 = 11;\\n    }\\n    oneof int32_or_float_or_uint64 {\\n        int32 v12 = 12;\\n        uint64 v13 = 13;\\n        float v14 = 14;\\n    }\\n    repeated uint64 uint64_array = 15;\\n    map<int32, string> int32_map = 16;\\n}');\r\n//----\r\n// DECODE FUNCTION\r\n//----\r\n(input) => {\r\n  const $Reader = typia_1.default.protobuf.createDecode.Reader;\r\n  const $pdo0 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      int32: undefined,\r\n      uint32: undefined,\r\n      uint64: undefined,\r\n      int64: undefined,\r\n      float: undefined,\r\n      double: undefined,\r\n      string: null,\r\n      uint32_or_double: undefined,\r\n      int32_or_uint64: undefined,\r\n      int32_or_float_or_uint64: undefined,\r\n      uint64_array: [],\r\n      int32_map: null,\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // int32;\r\n          output.int32 = reader.int32();\r\n          break;\r\n        case 2:\r\n          // uint32;\r\n          output.uint32 = reader.uint32();\r\n          break;\r\n        case 3:\r\n          // uint64;\r\n          output.uint64 = reader.uint64();\r\n          break;\r\n        case 4:\r\n          // int64;\r\n          output.int64 = Number(reader.int64());\r\n          break;\r\n        case 5:\r\n          // float;\r\n          output.float = reader.float();\r\n          break;\r\n        case 6:\r\n          // double;\r\n          output.double = reader.double();\r\n          break;\r\n        case 7:\r\n          // string;\r\n          output.string = reader.string();\r\n          break;\r\n        case 8:\r\n          // uint32;\r\n          output.uint32_or_double = reader.uint32();\r\n          break;\r\n        case 9:\r\n          // double;\r\n          output.uint32_or_double = reader.double();\r\n          break;\r\n        case 10:\r\n          // int32;\r\n          output.int32_or_uint64 = reader.int32();\r\n          break;\r\n        case 11:\r\n          // uint64;\r\n          output.int32_or_uint64 = reader.uint64();\r\n          break;\r\n        case 12:\r\n          // int32;\r\n          output.int32_or_float_or_uint64 = reader.int32();\r\n          break;\r\n        case 13:\r\n          // uint64;\r\n          output.int32_or_float_or_uint64 = reader.uint64();\r\n          break;\r\n        case 14:\r\n          // float;\r\n          output.int32_or_float_or_uint64 = reader.float();\r\n          break;\r\n        case 15:\r\n          // type: Array<(bigint & Type<\"uint64\">)>;\r\n          if (2 === (tag & 7)) {\r\n            const piece = reader.uint32() + reader.index();\r\n            while (reader.index() < piece)\r\n              output.uint64_array.push(reader.uint64());\r\n          } else output.uint64_array.push(reader.uint64());\r\n          break;\r\n        case 16:\r\n          // type: Map<string, string>;\r\n          (() => {\r\n            output.int32_map ??= new Map();\r\n            const piece = reader.uint32() + reader.index();\r\n            const entry = {\r\n              key: undefined,\r\n              value: \"\",\r\n            };\r\n            while (reader.index() < piece) {\r\n              const kind = reader.uint32();\r\n              switch (kind >>> 3) {\r\n                case 1:\r\n                  // int32;\r\n                  entry.key = reader.int32();\r\n                  break;\r\n                case 2:\r\n                  // string;\r\n                  entry.value = reader.string();\r\n                  break;\r\n                default:\r\n                  reader.skipType(kind & 7);\r\n                  break;\r\n              }\r\n            }\r\n            output.int32_map.set(entry.key, entry.value);\r\n          })();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const reader = new $Reader(input);\r\n  return $pdo0(reader);\r\n};\r\n//----\r\n// ENCODE FUNCTION\r\n//----\r\n(input) => {\r\n  const $throws = typia_1.default.protobuf.createEncode.throws;\r\n  const $Sizer = typia_1.default.protobuf.createEncode.Sizer;\r\n  const $Writer = typia_1.default.protobuf.createEncode.Writer;\r\n  const encoder = (writer) => {\r\n    const $peo0 = (input) => {\r\n      // property \"int32\";\r\n      writer.uint32(8);\r\n      writer.int32(input.int32);\r\n      // property \"uint32\";\r\n      writer.uint32(16);\r\n      writer.uint32(input.uint32);\r\n      // property \"uint64\";\r\n      writer.uint32(24);\r\n      writer.uint64(input.uint64);\r\n      // property \"int64\";\r\n      writer.uint32(32);\r\n      writer.int64(input.int64);\r\n      // property \"float\";\r\n      writer.uint32(45);\r\n      writer.float(input.float);\r\n      // property \"double\";\r\n      if (undefined !== input.double) {\r\n        writer.uint32(49);\r\n        writer.double(input.double);\r\n      }\r\n      // property \"string\";\r\n      if (null !== input.string) {\r\n        writer.uint32(58);\r\n        writer.string(input.string);\r\n      }\r\n      // property \"uint32_or_double\";\r\n      if (\r\n        \"number\" === typeof input.uint32_or_double &&\r\n        Math.floor(input.uint32_or_double) === input.uint32_or_double &&\r\n        0 <= input.uint32_or_double &&\r\n        input.uint32_or_double <= 4294967295\r\n      ) {\r\n        writer.uint32(64);\r\n        writer.uint32(input.uint32_or_double);\r\n      } else if (\"number\" === typeof input.uint32_or_double && true) {\r\n        writer.uint32(73);\r\n        writer.double(input.uint32_or_double);\r\n      } else\r\n        $throws({\r\n          expected: '(number & (Type<\"uint32\"> | Type<\"double\">))',\r\n          value: input.uint32_or_double,\r\n        });\r\n      // property \"int32_or_uint64\";\r\n      if (\"number\" === typeof input.int32_or_uint64) {\r\n        writer.uint32(80);\r\n        writer.int32(input.int32_or_uint64);\r\n      } else if (\"bigint\" === typeof input.int32_or_uint64) {\r\n        writer.uint32(88);\r\n        writer.uint64(input.int32_or_uint64);\r\n      } else\r\n        $throws({\r\n          expected: '((bigint & Type<\"uint64\">) | (number & Type<\"int32\">))',\r\n          value: input.int32_or_uint64,\r\n        });\r\n      // property \"int32_or_float_or_uint64\";\r\n      if (\r\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\r\n        Math.floor(input.int32_or_float_or_uint64) ===\r\n          input.int32_or_float_or_uint64 &&\r\n        -2147483648 <= input.int32_or_float_or_uint64 &&\r\n        input.int32_or_float_or_uint64 <= 2147483647\r\n      ) {\r\n        writer.uint32(96);\r\n        writer.int32(input.int32_or_float_or_uint64);\r\n      } else if (\"bigint\" === typeof input.int32_or_float_or_uint64) {\r\n        writer.uint32(104);\r\n        writer.uint64(input.int32_or_float_or_uint64);\r\n      } else if (\r\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\r\n        -1.175494351e38 <= input.int32_or_float_or_uint64 &&\r\n        input.int32_or_float_or_uint64 <= 3.4028235e38\r\n      ) {\r\n        writer.uint32(117);\r\n        writer.float(input.int32_or_float_or_uint64);\r\n      } else\r\n        $throws({\r\n          expected:\r\n            '((bigint & Type<\"uint64\">) | (number & (Type<\"int32\"> | Type<\"float\">)))',\r\n          value: input.int32_or_float_or_uint64,\r\n        });\r\n      // property \"uint64_array\";\r\n      if (0 !== input.uint64_array.length) {\r\n        writer.uint32(122);\r\n        writer.fork();\r\n        for (const elem of input.uint64_array) {\r\n          writer.uint64(elem);\r\n        }\r\n        writer.ldelim();\r\n      }\r\n      // property \"int32_map\";\r\n      if (undefined !== input.int32_map && null !== input.int32_map) {\r\n        for (const [key, value] of input.int32_map) {\r\n          writer.uint32(130);\r\n          writer.fork();\r\n          writer.uint32(8);\r\n          writer.int32(key);\r\n          writer.uint32(18);\r\n          writer.string(value);\r\n          writer.ldelim();\r\n        }\r\n      }\r\n    };\r\n    //TypeTagExample;\r\n    $peo0(input);\r\n    return writer;\r\n  };\r\n  const sizer = encoder(new $Sizer());\r\n  const writer = encoder(new $Writer(sizer));\r\n  return writer.buffer();\r\n};","comment-tags#Comment Tags":"By using @type {target} comment tag, you also can use special numeric types.However, this way is not recommended, because it can't perform union numeric types, and cannot be used in Array and Map types. When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a mis-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.\nimport typia from \"typia\";\r\n\r\nexport interface CommentTagExample {\r\n  /**\r\n   * @type int32\r\n   */\r\n  int32: number;\r\n\r\n  /**\r\n   * @type uint32\r\n   */\r\n  uint32?: number | null;\r\n\r\n  /**\r\n   * @type uint64\r\n   */\r\n  uint64?: number;\r\n\r\n  /**\r\n   * @type int64\r\n   */\r\n  int64: number;\r\n\r\n  /**\r\n   * @type float\r\n   */\r\n  float: number | null;\r\n\r\n  double: number;\r\n\r\n  string: string;\r\n}\r\n\r\n//----\r\n// PROTOBUF MESSAGE SCHEMA\r\n//----\r\ntypia.protobuf.message<CommentTagExample>();\r\n\r\n//----\r\n// DECODE FUNCTION\r\n//----\r\ntypia.protobuf.createDecode<CommentTagExample>();\r\n\r\n//----\r\n// ENCODE FUNCTION\r\n//----\r\ntypia.protobuf.createEncode<CommentTagExample>();\nsyntax = \"proto3\";\r\n\r\nmessage CommentTagExample {\r\n  required int32 int32 = 1;\r\n  optional uint32 uint32 = 2;\r\n  optional uint64 uint64 = 3;\r\n  required int64 int64 = 4;\r\n  optional float float = 5;\r\n  required double double = 6;\r\n  required string string = 7;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n//----\r\n// PROTOBUF MESSAGE SCHEMA\r\n//----\r\n('syntax = \"proto3\";\\n\\nmessage CommentTagExample {\\n    required int32 int32 = 1;\\n    optional uint32 uint32 = 2;\\n    optional uint64 uint64 = 3;\\n    required int64 int64 = 4;\\n    optional float float = 5;\\n    required double double = 6;\\n    required string string = 7;\\n}');\r\n//----\r\n// DECODE FUNCTION\r\n//----\r\n(input) => {\r\n  const $Reader = typia_1.default.protobuf.createDecode.Reader;\r\n  const $pdo0 = (reader, length = -1) => {\r\n    length = length < 0 ? reader.size() : reader.index() + length;\r\n    const output = {\r\n      int32: undefined,\r\n      uint32: null,\r\n      uint64: undefined,\r\n      int64: undefined,\r\n      float: null,\r\n      double: undefined,\r\n      string: \"\",\r\n    };\r\n    while (reader.index() < length) {\r\n      const tag = reader.uint32();\r\n      switch (tag >>> 3) {\r\n        case 1:\r\n          // int32;\r\n          output.int32 = reader.int32();\r\n          break;\r\n        case 2:\r\n          // uint32;\r\n          output.uint32 = reader.uint32();\r\n          break;\r\n        case 3:\r\n          // uint64;\r\n          output.uint64 = Number(reader.uint64());\r\n          break;\r\n        case 4:\r\n          // int64;\r\n          output.int64 = Number(reader.int64());\r\n          break;\r\n        case 5:\r\n          // float;\r\n          output.float = reader.float();\r\n          break;\r\n        case 6:\r\n          // double;\r\n          output.double = reader.double();\r\n          break;\r\n        case 7:\r\n          // string;\r\n          output.string = reader.string();\r\n          break;\r\n        default:\r\n          reader.skipType(tag & 7);\r\n          break;\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  const reader = new $Reader(input);\r\n  return $pdo0(reader);\r\n};\r\n//----\r\n// ENCODE FUNCTION\r\n//----\r\n(input) => {\r\n  const $Sizer = typia_1.default.protobuf.createEncode.Sizer;\r\n  const $Writer = typia_1.default.protobuf.createEncode.Writer;\r\n  const encoder = (writer) => {\r\n    const $peo0 = (input) => {\r\n      // property \"int32\";\r\n      writer.uint32(8);\r\n      writer.int32(input.int32);\r\n      // property \"uint32\";\r\n      if (undefined !== input.uint32 && null !== input.uint32) {\r\n        writer.uint32(16);\r\n        writer.uint32(input.uint32);\r\n      }\r\n      // property \"uint64\";\r\n      if (undefined !== input.uint64) {\r\n        writer.uint32(24);\r\n        writer.uint64(input.uint64);\r\n      }\r\n      // property \"int64\";\r\n      writer.uint32(32);\r\n      writer.int64(input.int64);\r\n      // property \"float\";\r\n      if (null !== input.float) {\r\n        writer.uint32(45);\r\n        writer.float(input.float);\r\n      }\r\n      // property \"double\";\r\n      writer.uint32(49);\r\n      writer.double(input.double);\r\n      // property \"string\";\r\n      writer.uint32(58);\r\n      writer.string(input.string);\r\n    };\r\n    //CommentTagExample;\r\n    $peo0(input);\r\n    return writer;\r\n  };\r\n  const sizer = encoder(new $Sizer());\r\n  const writer = encoder(new $Writer(sizer));\r\n  return writer.buffer();\r\n};","restrictions#Restrictions":"You know what? Expression power of Protocol Buffer is extremely narrower than type system of TypeScript. For example, Protocol Buffer can't express complicate union type containing array. Also, Protocol Buffer can't express multi dimensional array type, either.In such reason, when converting TypeScript type to Protocol buffer message schema, lots of restrictions are exist. Let's study which types of TyeScript are not supported in Protocol Buffer. For reference, if you try to call typia.protobuf.message<T>() function with unsupported type, typia will generate compile errors like below example cases.At first, top level type must be a sole and static object.If you try to use number or Array<T> type as a top level type, typia will generate compile error like below. Dynamic object types like Record<string, T>, or Map<string, T> types are not allowed either. For reference, the sole object means that, union of object types is not allowed, either.\nimport typia from \"typia\";\r\n\r\ninterface Cat {\r\n    type: \"cat\";\r\n    name: string;\r\n    ribbon: boolean;\r\n}\r\ninterface Dog {\r\n    type: \"dog\";\r\n    name: string;\r\n    hunt: boolean;\r\n}\r\n\r\ntypia.protobuf.message<bigint>();\r\ntypia.protobuf.createDecode<Record<string, number>>();\r\ntypia.protobuf.createDecode<Map<number & typia.tags.Type<\"float\">, Dog>>();\r\ntypia.protobuf.createEncode<boolean[]>();\r\ntypia.protobuf.createEncode<Cat | Dog>();\nmain.ts:14:1 - error TS(typia.protobuf.message): unsupported type detected\r\n\r\n- bigint\r\n  - target type must be a sole and static object type\r\n\r\nmain.ts:15:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\r\n\r\n- Record<string, number>\r\n  - target type must be a sole and static object type\r\n\r\nmain.ts:16:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\r\n\r\n- Map<(number & Type<\"float\">), Dog>\r\n  - target type must be a sole and static object type\r\n\r\n- (number & Type<\"float\">)\r\n  - target type must be a sole and static object type\r\n\r\nmain.ts:17:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\r\n\r\n- Array<boolean>\r\n  - target type must be a sole and static object type\r\n\r\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\r\n\r\n- (Cat | Dog)\r\n  - target type must be a sole and static object type\nAt next, in Protocol Buffer, those types are categorized as container types.\nArray<T>\nMap<Key, T>\nRecord<string, T> (dynamic object)\nAlso, those container types does not allow over two-dimensional stacking. Therefore, it is not possible to declaring two dimensional array like number[][], or Array type in Map like Map<string, number[]>. Besides, value type of those container also do not support union type either.Additionally, about Map<Key, T> type, key type must be an atomic type. It means that, only boolean, number, bigint and string types are allowed. Also, key type cannot be union type, either.\nimport typia from \"typia\";\r\n\r\ninterface IPointer<T> {\r\n  value: T;\r\n}\r\ninterface Cat {\r\n  type: \"cat\";\r\n  name: string;\r\n  ribbon: boolean;\r\n}\r\ninterface Dog {\r\n  type: \"dog\";\r\n  name: string;\r\n  hunt: boolean;\r\n}\r\n\r\ntypia.protobuf.message<IPointer<number[][]>>();\r\ntypia.protobuf.createEncode<IPointer<Record<string, string[]>>>();\r\ntypia.protobuf.createDecode<IPointer<Map<string, Cat | Dog>>>();\r\n\r\ntypia.protobuf.message<IPointer<Map<Cat, string>>>();\r\ntypia.protobuf.message<IPointer<Map<number | string, Dog>>>();\nmain.ts:17:1 - error TS(typia.protobuf.message): unsupported type detected\r\n\r\n- IPointer<Array<Array<number>>>[key]: Array<Array<number>>\r\n  - does not support over two dimenstional array type\r\n\r\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\r\n\r\n- IPointer<Record<string, Array<string>>>[key]: Record<string, Array<string>>\r\n  - does not support dynamic object with array value type\r\n\r\nmain.ts:19:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\r\n\r\n- IPointer<Map<string, Cat | Dog>>[key]: Map<string, (Cat | Dog)>\r\n  - does not support union type in map value type\r\n\r\nmain.ts:21:1 - error TS(typia.protobuf.message): unsupported type detected\r\n\r\n- IPointer<Map<Cat, string>>[key]: Map<Cat, string>\r\n  - does not support non-atomic key typed map\r\n\r\nmain.ts:22:1 - error TS(typia.protobuf.message): unsupported type detected\r\n\r\n- IPointer<Map<string | number, Dog>>[key]: Map<(number | string), Dog>\r\n  - does not support union key typed map\r\n  - does not support non-atomic key typed map\nAt last, those types are all not allowed.\nany\nfunctional type\nSet<T>, WeakSet<T> and WeakMap<T>\nDate, Boolean, BigInt, Number, String\nBinary classes except Uint8Array\nUint8ClampedArray, Uint16Array, Uint32Array, BigUint64Array\nInt8Array, Int16Array, Int32Array, BigInt64Array\nArrayBuffer, SharedArrayBuffer and DataView\nimport typia from \"typia\";\r\n\r\ninterface Something {\r\n  any: any;\r\n  unknown: unknown;\r\n  closure: () => void;\r\n  dict: Set<string> | WeakSet<Something> | WeakMap<Something, string>;\r\n  date: Date;\r\n  classic: String;\r\n  buffer: ArrayBuffer;\r\n}\r\n\r\ntypia.protobuf.message<Something>();\nmain.ts:13:1 - error TS(typia.protobuf.message): unsupported type detected\r\n\r\n- Something.any: any\r\n  - does not support any type\r\n\r\n- Something.unknown: any\r\n  - does not support any type\r\n\r\n- Something.closure: unknown\r\n  - does not support functional type\r\n\r\n- Something.dict: (Set<string> | WeakMap | WeakSet)\r\n  - does not support Set type\r\n  - does not support WeakSet type. Use Array type instead.\r\n  - does not support WeakMap type. Use Map type instead.\r\n\r\n- Something.date: Date\r\n  - does not support Date type. Use string type instead.\r\n\r\n- Something.classic: String\r\n  - does not support String type. Use string type instead.\r\n\r\n- Something.buffer: ArrayBuffer\r\n  - does not support ArrayBuffer type. Use Uint8Array type instead."}},"/docs/pure":{"title":"Pure TypeScript","data":{"outline#Outline":"typia.assert<IBbsArticle>(article);\ntypia needs only one line with pure TypeScript type.You know what? Every other validator libraries need extra schema definition, that is different with pure TypeScript type. For an example, class-validator is the most famous validator due to used in NestJS. However, NestJS and class-validator force you to define triple duplicated DTO schema.\nTypeScript Type\nclass-validator decorators\n@nestjs/swagger decorators\nAnother famous validator library ajv requires JSON schema definition. Move to the #Demonstration, and click the ajv (JSON Schema) tab, then you may understand how it terrible. It requires hundreds of lines of JSON schema definition even just for a simple DTO.Those duplicated schema definitions are not only annoying, but also error-prone. If you take any mistake on the extra schema definition, such mistake can't be detected by TypeScript compiler. It will be detected only at runtime, therefore become a critical runtime error. Another words, it is not type safe.Besides, typia only needs pure TypeScript type. You don't need to define any extra schema like class-validator or ajv. Just define pure TypeScript type only (especially recommend to use interface type), then typia will do all the rest.","demonstration#Demonstration":"If you're confusing how typia is different with others, just see example codes below.At first, look at the first (class-validator) tab, and find the BbsArticle.files property, enhanced by blue coloured blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime erorr.Besides, typia needs only one line. Click the third (typia) tab, and find the IAttachmentFile.files property. Only one line being used, and they are even not class, but just interface types. Comparing it to the first and second tabs, how do you feel? Isn't it more simple and readable?This is the power of typia, with pure TypeScript type.\nimport { ApiProperty } from \"@nestjs/swagger\";\r\nimport {\r\n  ArrayNotEmpty,\r\n  IsArray,\r\n  IsObject,\r\n  IsOptional,\r\n  IsString,\r\n  Match,\r\n  MaxLength,\r\n  Type,\r\n  ValidateNested,\r\n} from \"class-validator\";\r\n\r\nexport class BbsArticle {\r\n  @ApiProperty({\r\n    format: \"uuid\",\r\n  })\r\n  @IsString()\r\n  id!: string;\r\n\r\n  // DUPLICATED SCHEMA DEFINITION\r\n  // - duplicated function call + property type\r\n  // - have to specify `isArray` and `nullable` props by yourself\r\n  @ApiProperty({\r\n    type: () => AttachmentFile,\r\n    nullable: true,\r\n    isArray: true,\r\n    description: \"List of attached files.\",\r\n  })\r\n  @Type(() => AttachmentFile)\r\n  @IsArray()\r\n  @IsOptional()\r\n  @IsObject({ each: true })\r\n  @ValidateNested({ each: true })\r\n  files!: AttachmentFile[] | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    minLength: 5,\r\n    maxLength: 100,\r\n    description: \"Title of the article.\",\r\n  })\r\n  @IsOptional()\r\n  @IsString()\r\n  title!: string | null;\r\n\r\n  @ApiProperty({\r\n    description: \"Main content body of the article.\",\r\n  })\r\n  @IsString()\r\n  body!: string;\r\n\r\n  @ApiProperty({\r\n    format: \"date-time\",\r\n    description: \"Creation time of article\",\r\n  })\r\n  @IsString()\r\n  created_at!: string;\r\n}\r\n\r\nexport class AttachmentFile {\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File name.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(255)\r\n  @IsString()\r\n  name!: string | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File extension.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(8)\r\n  @IsOptional()\r\n  @IsString()\r\n  extension!: string | null;\r\n\r\n  @ApiProperty({\r\n    format: \"url\",\r\n    description: \"URL of the file.\",\r\n  })\r\n  @IsString()\r\n  url!: string;\r\n}\n{\r\n  \"schemas\": [\r\n    {\r\n      \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n    }\r\n  ],\r\n  \"components\": {\r\n    \"schemas\": {\r\n      \"IBbsArticle\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uuid\",\r\n            \"title\": \"Primary Key\",\r\n            \"description\": \"Primary Key.\"\r\n          },\r\n          \"files\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\r\n            },\r\n            \"nullable\": true,\r\n            \"title\": \"List of attached files\",\r\n            \"description\": \"List of attached files.\"\r\n          },\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 100,\r\n            \"minLength\": 5,\r\n            \"nullable\": true,\r\n            \"title\": \"Title of the article\",\r\n            \"description\": \"Title of the article.\"\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Main content body of the article\",\r\n            \"description\": \"Main content body of the article.\"\r\n          },\r\n          \"created_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\",\r\n            \"title\": \"Creation time of article\",\r\n            \"description\": \"Creation time of article.\"\r\n          }\r\n        },\r\n        \"nullable\": false,\r\n        \"required\": [\r\n          \"id\",\r\n          \"files\",\r\n          \"title\",\r\n          \"body\",\r\n          \"created_at\"\r\n        ]\r\n      },\r\n      \"IAttachmentFile\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"name\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 255,\r\n            \"pattern\": \"^[a-z0-9]+$\",\r\n            \"title\": \"File name\",\r\n            \"description\": \"File name.\"\r\n          },\r\n          \"extension\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 8,\r\n            \"pattern\": \"^[a-z0-9]+$\",\r\n            \"nullable\": true,\r\n            \"title\": \"File extension\",\r\n            \"description\": \"File extension.\"\r\n          },\r\n          \"url\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"URL of the file\",\r\n            \"description\": \"URL of the file.\"\r\n          }\r\n        },\r\n        \"nullable\": false,\r\n        \"required\": [\r\n          \"name\",\r\n          \"extension\",\r\n          \"url\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"purpose\": \"swagger\",\r\n  \"surplus\": false\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  /**\r\n   * Primary Key.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n\r\n  /**\r\n   * List of attached files.\r\n   */\r\n  files: null | IAttachmentFile[];\r\n\r\n  /**\r\n   * Title of the article.\r\n   */\r\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\r\n\r\n  /**\r\n   * Main content body of the article.\r\n   */\r\n  body: string;\r\n\r\n  /**\r\n   * Creation time of article.\r\n   */\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  /**\r\n   * File name.\r\n   */\r\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\r\n\r\n  /**\r\n   * File extension.\r\n   */\r\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\r\n\r\n  /**\r\n   * URL of the file.\r\n   */\r\n  url: string;\r\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can typia validates types at runtime? How typia builds much faster JSON serializer only with these types? Are these things really possible without extra schema definition like class-validator or ajv?\"\nMy answer is: \"Yes, it is possible due to typia analyzes your server code, and performs AOT compilation\".Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why typia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why typia is much easier, and futhermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\nimport typia, { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  /**\r\n   * Primary Key.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n\r\n  /**\r\n   * List of attached files.\r\n   */\r\n  files: null | IAttachmentFile[];\r\n\r\n  /**\r\n   * Title of the article.\r\n   */\r\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\r\n\r\n  /**\r\n   * Main content body of the article.\r\n   */\r\n  body: string;\r\n\r\n  /**\r\n   * Creation time of article.\r\n   */\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  /**\r\n   * File name.\r\n   */\r\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\r\n\r\n  /**\r\n   * File extension.\r\n   */\r\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\r\n\r\n  /**\r\n   * URL of the file.\r\n   */\r\n  url: string;\r\n}\nimport typia from \"typia\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\n\r\nexport const assertArticle = typia.createAssert<IBbsArticle>();\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n  return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.assertArticle = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst assertArticle = (input) => {\r\n  const __is = (input) => {\r\n    const $io0 = (input) =>\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      (null === input.files ||\r\n        (Array.isArray(input.files) &&\r\n          input.files.every(\r\n            (elem) => \"object\" === typeof elem && null !== elem && $io1(elem),\r\n          ))) &&\r\n      (null === input.title ||\r\n        (\"string\" === typeof input.title &&\r\n          5 <= input.title.length &&\r\n          input.title.length <= 100)) &&\r\n      \"string\" === typeof input.body &&\r\n      \"string\" === typeof input.created_at &&\r\n      !isNaN(new Date(input.created_at).getTime());\r\n    const $io1 = (input) =>\r\n      \"string\" === typeof input.name &&\r\n      /^[a-z0-9]+$/.test(input.name) &&\r\n      input.name.length <= 255 &&\r\n      (null === input.extension ||\r\n        (\"string\" === typeof input.extension &&\r\n          /^[a-z0-9]+$/.test(input.extension) &&\r\n          input.extension.length <= 8)) &&\r\n      \"string\" === typeof input.url;\r\n    return \"object\" === typeof input && null !== input && $io0(input);\r\n  };\r\n  if (false === __is(input))\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $guard = typia_1.default.createAssert.guard;\r\n      const $ao0 = (input, _path, _exceptionable = true) =>\r\n        ((\"string\" === typeof input.id &&\r\n          (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n            input.id,\r\n          ) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: 'string & Format<\"uuid\">',\r\n              value: input.id,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".id\",\r\n            expected: '(string & Format<\"uuid\">)',\r\n            value: input.id,\r\n          })) &&\r\n        (null === input.files ||\r\n          ((Array.isArray(input.files) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".files\",\r\n              expected: \"(Array<IAttachmentFile> | null)\",\r\n              value: input.files,\r\n            })) &&\r\n            input.files.every(\r\n              (elem, _index1) =>\r\n                (((\"object\" === typeof elem && null !== elem) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files[\" + _index1 + \"]\",\r\n                    expected: \"IAttachmentFile\",\r\n                    value: elem,\r\n                  })) &&\r\n                  $ao1(\r\n                    elem,\r\n                    _path + \".files[\" + _index1 + \"]\",\r\n                    true && _exceptionable,\r\n                  )) ||\r\n                $guard(_exceptionable, {\r\n                  path: _path + \".files[\" + _index1 + \"]\",\r\n                  expected: \"IAttachmentFile\",\r\n                  value: elem,\r\n                }),\r\n            )) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".files\",\r\n            expected: \"(Array<IAttachmentFile> | null)\",\r\n            value: input.files,\r\n          })) &&\r\n        (null === input.title ||\r\n          (\"string\" === typeof input.title &&\r\n            (5 <= input.title.length ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".title\",\r\n                expected: \"string & MinLength<5>\",\r\n                value: input.title,\r\n              })) &&\r\n            (input.title.length <= 100 ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".title\",\r\n                expected: \"string & MaxLength<100>\",\r\n                value: input.title,\r\n              }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".title\",\r\n            expected: \"((string & MinLength<5> & MaxLength<100>) | null)\",\r\n            value: input.title,\r\n          })) &&\r\n        (\"string\" === typeof input.body ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".body\",\r\n            expected: \"string\",\r\n            value: input.body,\r\n          })) &&\r\n        ((\"string\" === typeof input.created_at &&\r\n          (!isNaN(new Date(input.created_at).getTime()) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".created_at\",\r\n              expected: 'string & Format<\"date-time\">',\r\n              value: input.created_at,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".created_at\",\r\n            expected: '(string & Format<\"date-time\">)',\r\n            value: input.created_at,\r\n          }));\r\n      const $ao1 = (input, _path, _exceptionable = true) =>\r\n        ((\"string\" === typeof input.name &&\r\n          (/^[a-z0-9]+$/.test(input.name) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: 'string & Pattern<\"^[a-z0-9]+$\">',\r\n              value: input.name,\r\n            })) &&\r\n          (input.name.length <= 255 ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".name\",\r\n              expected: \"string & MaxLength<255>\",\r\n              value: input.name,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".name\",\r\n            expected: '(string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<255>)',\r\n            value: input.name,\r\n          })) &&\r\n        (null === input.extension ||\r\n          (\"string\" === typeof input.extension &&\r\n            (/^[a-z0-9]+$/.test(input.extension) ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".extension\",\r\n                expected: 'string & Pattern<\"^[a-z0-9]+$\">',\r\n                value: input.extension,\r\n              })) &&\r\n            (input.extension.length <= 8 ||\r\n              $guard(_exceptionable, {\r\n                path: _path + \".extension\",\r\n                expected: \"string & MaxLength<8>\",\r\n                value: input.extension,\r\n              }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".extension\",\r\n            expected:\r\n              '((string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<8>) | null)',\r\n            value: input.extension,\r\n          })) &&\r\n        (\"string\" === typeof input.url ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".url\",\r\n            expected: \"string\",\r\n            value: input.url,\r\n          }));\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IBbsArticle\",\r\n            value: input,\r\n          })) &&\r\n          $ao0(input, _path + \"\", true)) ||\r\n        $guard(true, {\r\n          path: _path + \"\",\r\n          expected: \"IBbsArticle\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  return input;\r\n};\r\nexports.assertArticle = assertArticle;\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/setup":{"title":"Setup","data":{"summary#Summary":"npm install typia\r\nnpx typia setup\npnpm install typia\r\npnpm typia setup --manager pnpm\nYarn berry is not supported.\nyarn add typia\r\nyarn typia setup --manager yarn\nIf you're using standard TypeScript compiler, you can use transform mode.Just run npx typia setup command, then everything be prepared.\nStandard TypeScript Compiler: Microsoft/TypeScript\nnpm install typia\r\nnpm install --save-dev typescript\r\n\r\nnpx typia generate \\\r\n  --input src/templates \\\r\n  --output src/generated \\\r\n  --project tsconfig.json\npnpm install typia\r\npnpm install --save-dev typescript\r\n\r\npnpm typia generate \\\r\n  --input src/templates \\\r\n  --output src/generated \\\r\n  --project tsconfig.json\nyarn add typia\r\nyarn add -D typescript\r\n\r\nyarn typia generate \\\r\n  --input src/templates \\\r\n  --output src/generated \\\r\n  --project tsconfig.json\nOtherwise you are using non-standard TypeScript compiler, then you can't use transformation mode.Instead, you can use generation mode.Run typia generate command with input directory, then transformed TypeScript files would be generated into the output directory.\nNon-standard TypeScript Compilers\nSWC\nESBuild\nBabel","transformation#Transformation":"","concepts#Concepts":"AOT (Ahead of Time) compilation mode.When you write a TypeScript code calling typia.createIs<IMember>() function and compile it through tsc command, typia will replace the typia.createIs<IMember>() statement to optimal validation code in the compiled JavaScript file, for the IMember type.This is the transform mode performing AOT (Ahead of Time) compilation.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const check = typia.createIs<IMember>();\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.check = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst check = (input) => {\r\n  return (\r\n    \"object\" === typeof input &&\r\n    null !== input &&\r\n    \"string\" === typeof input.id &&\r\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n      input.id,\r\n    ) &&\r\n    \"string\" === typeof input.email &&\r\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n      input.email,\r\n    ) &&\r\n    \"number\" === typeof input.age &&\r\n    19 < input.age &&\r\n    input.age <= 100\r\n  );\r\n};\r\nexports.check = check;","setup-wizard#Setup Wizard":"npm install --save typia\r\nnpx typia setup\npnpm install --save typia\r\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\r\nyarn add typia\r\nyarn typia setup --manager yarn\nYou can turn on transformation mode just by running npx typia setup command.Setup wizard would be executed, and it will do everything for the transformation.","manual-setup#Manual Setup":"npm install --save typia\r\nnpm install --save-dev typescript ts-patch ts-node\npnpm install --save typia\r\npnpm install --save-dev typescript ts-patch ts-node\n# YARN BERRY IS NOT SUPPORTED\r\nyarn add typia\r\nyarn add -D typescript ts-patch ts-node\nIf you want to install typia manually, just follow the steps.At first, install typia as depepdency. And then, install typescript, ts-patch and ts-node as devDependencies.\n{\r\n  \"strict\": true,\r\n  \"strictNullChecks\": true,\r\n  \"compilerOptions\": {\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" }\r\n    ]\r\n  }\r\n}\nAt second, open your tsconfig.json file and configure like above.As typia generates optimal operation code through transformation, you've to configure it as a plugin. Also, never forget to configure strict (or strictNullChecks) to be true. It is essential option for modern TypeScript development.\n{\r\n  \"scripts\": {\r\n    \"prepare\": \"ts-patch install && typia patch\"\r\n  },\r\n  \"dependencies\": {\r\n    \"typia\": \"^4.1.8\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"ts-node\": \"^10.9.1\",\r\n    \"ts-patch\": \"^3.0.2\",\r\n    \"typescript\": \"^5.1.6\"\r\n  }\r\n}\nnpm run prepare\npnpm prepare\n# YARN BERRY IS NOT SUPPORTED\r\nyarn prepare\nAt last, open package.json file and configure npm run prepare command like above.Of course, you've to run the npm run prepare command after the configuration.For reference, ts-patch is an helper library of TypeScript compiler that supporting custom transformations by plugins. From now on, whenever you run tsc command, your typia function call statements would be transformed to the optimal operation codes in the compiled JavaScript files.\nnpx typia patch\nSince TypeScript v5.3 update, tsc no more parses JSDocComments. Therefore, typia also cannot utilize those JSDocComment related features too, especially \"Comment Tags\" and \"JSON schema generator\".The npx typia patch command has been developed to revive the JSDocComment parsing feature of tsc. It is temporary solution for the TypeScript v5.3 update instead of ts-patch, and will be disabled after ts-patch starts supporting such TypeScript v5.3 update.Of course, if you don't use any \"Comment Tags\" and \"JSON schema generator\", you don't need to run npx typia patch command. This is not mandatory command, but just optional command.","generation#Generation":"# INSTALL TYPIA\r\nnpm install --save typia\r\nnpm install --save-dev typescript\r\n\r\n# GENERATE TRANSFORMED TYPESCRIPT CODES\r\nnpx typia generate \\\r\n  --input src/templates \\\r\n  --output src/generated \\\r\n  --project tsconfig.json\n# INSTALL TYPIA\r\npnpm install --save typia\r\npnpm install --save-dev typescript\r\n\r\n# GENERATE TRANSFORMED TYPESCRIPT CODES\r\npnpm typia generate \\\r\n  --input src/templates \\\r\n  --output src/generated \\\r\n  --project tsconfig.json\n# INSTALL TYPIA\r\nyarn add typia\r\nyarn add -D typescript\r\n\r\n# GENERATE TRANSFORMED TYPESCRIPT CODES\r\nyarn typia generate \\\r\n  --input src/templates \\\r\n  --output src/generated \\\r\n  --project tsconfig.json\nFor frontend projects.If you're using non-standard TypeScript compiler, you can't use transform mode\nNon-standard TypeScript compilers:\nSWC in Next.JS\nESBuild in Vite\nBabel in Create-React-App\nInstead, you should utilize the generation mode.Install typia through npm install command, and run typia generate command. Then, generator of typia reads your TypeScript codes of --input, and writes transformed TypeScript files into the --output directory, like below.If you want to specify other TypeScript project file instead of tsconfig.json, you can use --project option.\nimport typia from \"typia\";\r\n\r\nimport { IMember } from \"../structures/IMember\";\r\n\r\nexport const check = typia.createIs<IMember>();\nimport typia from \"typia\";\r\nimport { IMember } from \"../structures/IMember\";\r\nexport const check = (input: any): input is IMember => {\r\n  const $is_uuid = (typia.createIs as any).is_uuid;\r\n  const $is_email = (typia.createIs as any).is_email;\r\n  return (\r\n    \"object\" === typeof input &&\r\n    null !== input &&\r\n    \"string\" === typeof input.id &&\r\n    $is_uuid(input.id) &&\r\n    \"string\" === typeof input.email &&\r\n    $is_email(input.email) &&\r\n    \"number\" === typeof input.age &&\r\n    19 <= input.age &&\r\n    100 >= input.age\r\n  );\r\n};\nWhy not support non-standard compilers?\nNon-standard TypeScript compilers are removing every type informations, and skipping type checkings for rapid compilation. By the way, without those type informations, typia can't do anything. This is the reason why typia doesn't support non-standard TypeScript compilers.By the way, SWC is preparing a new project STC keeping type informations. Therefore, typia will support it.","vite#Vite":"If you've made your frontend project through vite, you can still utilize the transformation mode.Just configure vite.config.ts file below, that's all.\nimport { defineConfig } from 'vite'\r\nimport react from '@vitejs/plugin-react'\r\nimport typescript from \"rollup-plugin-typescript2\";\r\n\r\n// https://vitejs.dev/config/\r\nexport default defineConfig({\r\n  esbuild: false,\r\n  plugins: [\r\n    react(),\r\n    typescript(),\r\n  ],\r\n});\nBy the way, if you're composing monorepo, and need to import some external TypeScript files from the other package of the monorepo, you've to configure the vite.config.ts a little bit different. When declaring typescript plugin, you've to specify include and exclude options like below.\nimport { defineConfig } from 'vite'\r\nimport react from '@vitejs/plugin-react'\r\nimport typescript from \"rollup-plugin-typescript2\";\r\n\r\n// https://vitejs.dev/config/\r\nexport default defineConfig({\r\n  esbuild: false,\r\n  plugins: [\r\n    react(),\r\n    typescript({\r\n      // WHEN MONOREPO\r\n      include: [\r\n        \"./**/*.ts+(|x)\",\r\n        \"../../core/**/*.ts+(|x)\",\r\n        \"../../util/**/*.ts+(|x)\",\r\n      ],\r\n      exclude: [\"../../node_modules\"],\r\n    }),\r\n  ],\r\n});","webpack#Webpack":"# TYPIA\r\nnpm install typia\r\nnpx typia setup\r\n\r\n# WEBPACK + TS-LOADER\r\nnpm install --save-dev ts-loader\r\nnpm install --save-dev webpack webpack-cli\n# TYPIA\r\npnpm install typia\r\npnpm typia setup --manager pnpm\r\n\r\n# WEBPACK + TS-LOADER\r\npnpm install --save-dev ts-loader\r\npnpm install --save-dev webpack webpack-cli\n###########################################\r\n# YARN BERRY IS NOT SUPPORTED\r\n###########################################\r\n# TYPIA\r\nyarn add typia\r\nyarn typia setup --manager yarn\r\n\r\n# WEBPACK + TS-LOADER\r\nyarn add -D ts-loader\r\nyarn add -D webpack webpack-cli\nWhen you're using webpack as a bundler, you can still utilize the transformation mode.Just install ts-loader as well as webpack, and configure webpack.config.js file like below.\nconst path = require(\"path\");\r\nconst nodeExternals = require(\"webpack-node-externals\");\r\n\r\nmodule.exports = {\r\n  // CUSTOMIZE HERE\r\n  entry: [\"./src/index.tsx\"],\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"index.js\",\r\n  },\r\n  optimization: {\r\n    minimize: false,\r\n  },\r\n\r\n  // JUST KEEP THEM\r\n  mode: \"development\",\r\n  target: \"node\",\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ts$/,\r\n        exclude: /node_modules/,\r\n        loader: \"ts-loader\",\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".tsx\", \".ts\", \".js\"],\r\n  },\r\n};\nFrom now on, you can build the single JS file just by running the npx webpack command. By the way, when removing devDependencies for --production install, never forget to add the --ignore-scripts option to prevent the prepare script.\nnpx webpack\r\nnpm ci --omit=dev --ignore-scripts\npnpm webpack\r\npnpm install --production --ignore-scripts\nyarn webpack\r\nrm -rf node_modules\r\nyarn install --production --ignore-scripts --immutable\nAdditionally, if you're using typia in the NodeJS project especially for the backend development, Setup Guide Documents of nestia would be helpful. Even though you're not using NestJS, you can still utilize below documents, and \"Single JS file only\" mode would be especially helpful for you.\nNestia > Setup > Webpack\nWith node_modules\nSingle JS file only","nx#NX":"npm install --save typia\r\nnpx typia setup\npnpm install --save typia\r\npnpm typia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\r\nyarn add typia\r\nyarn typia setup --manager yarn\nAfter install typia like above, you have to modify project.json on each app like below.\n \"targets\": {\r\n    \"build\": {\r\n      ...\r\n      \"options\": {\r\n        ...\r\n        \"target\": \"node\",\r\n        \"compiler\": \"tsc\",\r\n        \"transformers\": [\r\n          \"typia/lib/transform\",\r\n        ]\r\n      }\r\n    },\r\n    ...\r\n }"}},"/docs/validators/assert":{"title":"Assert","data":{"assert-function#assert() function":"export function assert<T>(input: T): T;\r\nexport function assert<T>(input: unknown): T;\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nAsserts a value type.typia.assert<T>() function throws a TypeGuardError when wrong type comes.The TypeGuardError instance has only the first type error info, with access path and expected type. In the below example case, as the age property is wrong with its definition (@exclusiveMinimum), such TypeGuardError would be thrown:\nmethod: typia.assert()\npath: input.age\nvalue: 18,\nexpected: number & ExclusiveMinimum<19>\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\nimport typia, { tags } from \"typia\";\r\nimport { v4 } from \"uuid\";\r\n\r\ntypia.assert<IMember>({\r\n  id: v4(),\r\n  email: \"samchon.github@gmail.com\",\r\n  age: 18, // wrong, must be greater than 19\r\n});\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst uuid_1 = require(\"uuid\");\r\n((input) => {\r\n  const __is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.email &&\r\n      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n        input.email,\r\n      ) &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100\r\n    );\r\n  };\r\n  if (false === __is(input))\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $guard = typia_1.default.assert.guard;\r\n      const $ao0 = (input, _path, _exceptionable = true) =>\r\n        ((\"string\" === typeof input.id &&\r\n          (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n            input.id,\r\n          ) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: 'string & Format<\"uuid\">',\r\n              value: input.id,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".id\",\r\n            expected: '(string & Format<\"uuid\">)',\r\n            value: input.id,\r\n          })) &&\r\n        ((\"string\" === typeof input.email &&\r\n          (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n            input.email,\r\n          ) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".email\",\r\n              expected: 'string & Format<\"email\">',\r\n              value: input.email,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".email\",\r\n            expected: '(string & Format<\"email\">)',\r\n            value: input.email,\r\n          })) &&\r\n        ((\"number\" === typeof input.age &&\r\n          ((Math.floor(input.age) === input.age &&\r\n            0 <= input.age &&\r\n            input.age <= 4294967295) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: 'number & Type<\"uint32\">',\r\n              value: input.age,\r\n            })) &&\r\n          (19 < input.age ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"number & ExclusiveMinimum<19>\",\r\n              value: input.age,\r\n            })) &&\r\n          (input.age <= 100 ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"number & Maximum<100>\",\r\n              value: input.age,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".age\",\r\n            expected:\r\n              '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n            value: input.age,\r\n          }));\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IMember\",\r\n            value: input,\r\n          })) &&\r\n          $ao0(input, _path + \"\", true)) ||\r\n        $guard(true, {\r\n          path: _path + \"\",\r\n          expected: \"IMember\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  return input;\r\n})({\r\n  id: (0, uuid_1.v4)(),\r\n  email: \"samchon.github@gmail.com\",\r\n  age: 18, // wrong, must be greater than 19\r\n});","assertequals-function#assertEquals() function":"export function assertEquals<T>(input: T): T;\r\nexport function assertEquals<T>(input: unknown): T;\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nMore strict assert function prohibiting superfluous properties.typia.assert<T>() function inspects input value type and throws TypeGuardError when mismatched, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, therefore throws an TypeGuardError when superfluous property exists, use typia.assertEquals<T()> function instead.In the below example case, as sex property is not defined in the IMember type, such TypeGuardError would be thrown:\nmethod: typia.assertEquals()\npath: input.sex\nvalue: 1,\r\n expected: undefined\nimport typia, { tags } from \"typia\";\r\nimport { v4 } from \"uuid\";\r\n\r\ntypia.assert<IMember>({\r\n  id: v4(),\r\n  email: \"samchon.github@gmail.com\",\r\n  age: 30,\r\n  sex: 1, // extra\r\n});\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst uuid_1 = require(\"uuid\");\r\n((input) => {\r\n  const __is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.email &&\r\n      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n        input.email,\r\n      ) &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100\r\n    );\r\n  };\r\n  if (false === __is(input))\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $guard = typia_1.default.assert.guard;\r\n      const $ao0 = (input, _path, _exceptionable = true) =>\r\n        ((\"string\" === typeof input.id &&\r\n          (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n            input.id,\r\n          ) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: 'string & Format<\"uuid\">',\r\n              value: input.id,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".id\",\r\n            expected: '(string & Format<\"uuid\">)',\r\n            value: input.id,\r\n          })) &&\r\n        ((\"string\" === typeof input.email &&\r\n          (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n            input.email,\r\n          ) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".email\",\r\n              expected: 'string & Format<\"email\">',\r\n              value: input.email,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".email\",\r\n            expected: '(string & Format<\"email\">)',\r\n            value: input.email,\r\n          })) &&\r\n        ((\"number\" === typeof input.age &&\r\n          ((Math.floor(input.age) === input.age &&\r\n            0 <= input.age &&\r\n            input.age <= 4294967295) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: 'number & Type<\"uint32\">',\r\n              value: input.age,\r\n            })) &&\r\n          (19 < input.age ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"number & ExclusiveMinimum<19>\",\r\n              value: input.age,\r\n            })) &&\r\n          (input.age <= 100 ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"number & Maximum<100>\",\r\n              value: input.age,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".age\",\r\n            expected:\r\n              '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n            value: input.age,\r\n          }));\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IMember\",\r\n            value: input,\r\n          })) &&\r\n          $ao0(input, _path + \"\", true)) ||\r\n        $guard(true, {\r\n          path: _path + \"\",\r\n          expected: \"IMember\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  return input;\r\n})({\r\n  id: (0, uuid_1.v4)(),\r\n  email: \"samchon.github@gmail.com\",\r\n  age: 30,\r\n  sex: 1, // extra\r\n})","assertguard-functions#assertGuard() functions":"export function assertGurad<T>(input: T): asserts inut is T;\r\nexport function assertGuard<T>(input: unknown): asserts input is T;\r\n\r\nexport function assertGuardEquals<T>(input: T): asserts inut is T;\r\nexport function assertGuardEquals<T>(input: unknown): asserts input is T;\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nAssertion guard of a value type.typia.assertGuard<T>() is similar with typia.assert<T>() throwing a TypeGuardError when wrong type.However, typia.assert<T>() returns the paramteric input value itself when there's no type problem on the parametric input value, whereas the typia.assertGuard<T>() function returns nothing. Instead, the parametric input value would be automatically cased to the type T. This is the concept of \"Assertion Guard\" of a value type.Such similarities and differences of typia.assertGuard<T>() and typia.assert<T>() functions are the same in the case of typia.assertGuardEquals<T>() and typia.assertEquals<T>() functions. If there's no type problem on the typia.assertGuardEquals<T>() function, it also performs the \"Assertion Guard\".Look at the below code, then you may understand what the \"Assertion Guard\" means.\nimport typia from \"typia\";\r\n\r\ninterface IPoint {\r\n  x: number;\r\n  y: number;\r\n}\r\nconst input: unknown = { x: 1, y: 2 };\r\n\r\n// PERFORM THE ASSERTION GUARD\r\ntypia.assertGuard<IPoint>(input);\r\n\r\n// FROM NOW ON, \"input\" IS THE \"IPoint\" TYPE\r\ninput.x; // OK\r\ninput.y; // OK","reusable-functions#Reusable functions":"export function createAssert<T>(): (input: unknown) => T;\r\nexport function createAssertEquals<T>(): (input: unknown) => T;\r\n\r\nexport function createAssertGuard<T>(): AssertionGuard<T>;\r\nexport function createAssertGuardEquals<T>(): AssertionGuard<T>;\nexport class TypeGuardError extends Error {\r\n  public readonly method: string;\r\n  public readonly path: string | undefined;\r\n  public readonly expected: string;\r\n  public readonly value: any;\r\n}\nexport type AssertionGuard<T> = (input: unknown) => asserts input is T;\nReusable typia.assert<T>() function generators.If you repeat to call typia.assert<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createAssert<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const assertMember = typia.createAssert<IMember>();\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.assertMember = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst assertMember = (input) => {\r\n  const __is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.email &&\r\n      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n        input.email,\r\n      ) &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100\r\n    );\r\n  };\r\n  if (false === __is(input))\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $guard = typia_1.default.createAssert.guard;\r\n      const $ao0 = (input, _path, _exceptionable = true) =>\r\n        ((\"string\" === typeof input.id &&\r\n          (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n            input.id,\r\n          ) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: 'string & Format<\"uuid\">',\r\n              value: input.id,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".id\",\r\n            expected: '(string & Format<\"uuid\">)',\r\n            value: input.id,\r\n          })) &&\r\n        ((\"string\" === typeof input.email &&\r\n          (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n            input.email,\r\n          ) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".email\",\r\n              expected: 'string & Format<\"email\">',\r\n              value: input.email,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".email\",\r\n            expected: '(string & Format<\"email\">)',\r\n            value: input.email,\r\n          })) &&\r\n        ((\"number\" === typeof input.age &&\r\n          ((Math.floor(input.age) === input.age &&\r\n            0 <= input.age &&\r\n            input.age <= 4294967295) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: 'number & Type<\"uint32\">',\r\n              value: input.age,\r\n            })) &&\r\n          (19 < input.age ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"number & ExclusiveMinimum<19>\",\r\n              value: input.age,\r\n            })) &&\r\n          (input.age <= 100 ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected: \"number & Maximum<100>\",\r\n              value: input.age,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".age\",\r\n            expected:\r\n              '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n            value: input.age,\r\n          }));\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"IMember\",\r\n            value: input,\r\n          })) &&\r\n          $ao0(input, _path + \"\", true)) ||\r\n        $guard(true, {\r\n          path: _path + \"\",\r\n          expected: \"IMember\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  return input;\r\n};\r\nexports.assertMember = assertMember;\nExplicity of Assertion Guard\nBe careful when using typia.createAssertGuard<T>() or typia.createAssertGuardEquals<T>() functions.When calling those functions, you've to declare the variable type explicit on the caller variable. If you don't do it, so that the caller variables come the implicit function type, TypeScript compiler throws an error like below. This is a special limitation of TypeScript compiler about the \"Assertion Guard\".\nimport typia, { AssertionGuard } from \"typia\";\r\n\r\n//MUST DECLARE THE VARIABLE TYPE\r\nconst explicit: AssertionGuard<number> = typia.createAssertGuard<number>();\r\n\r\n// IF NOT, COMPILATION ERROR BE OCCURED\r\nconst implicit = typia.createAssertGuard<number>();\nAssertions require every name in the call target to be declared with an explicit type annotation.","restrictions#Restrictions":"typia.assert<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.assert<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.assert<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\r\n  \"compilerOptions\": {\r\n    \"plugins\": [\r\n      {\r\n        \"transform\": \"typia/lib/transform\",\r\n        \"functional\": true\r\n      }\r\n    ]\r\n  }\r\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.assert<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.assert<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.\nimport typia from \"typia\";\r\n\r\ntypia.createIs<Map<string, boolean | number | string>>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  return (\r\n    input instanceof Map &&\r\n    (() =>\r\n      [...input].every(\r\n        (elem) =>\r\n          Array.isArray(elem) &&\r\n          elem.length === 2 &&\r\n          \"string\" === typeof elem[0] &&\r\n          (\"string\" === typeof elem[1] ||\r\n            \"number\" === typeof elem[1] ||\r\n            \"boolean\" === typeof elem[1]),\r\n      ))()\r\n  );\r\n};","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const assertSomething = typia.createAssert<Something>();\r\n\r\n//----\r\n// DEFINE CUSTOM TYPE TAGS\r\n//----\r\ntype Dollar = tags.TagBase<{\r\n  kind: \"dollar\";\r\n  target: \"string\";\r\n  value: undefined;\r\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\r\n}>;\r\n\r\ntype Postfix<Value extends string> = tags.TagBase<{\r\n  kind: \"postfix\";\r\n  target: \"string\";\r\n  value: Value;\r\n  validate: `$input.endsWith(\"${Value}\")`;\r\n}>;\r\n\r\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\r\n  kind: \"isEven\";\r\n  target: Value extends number ? \"number\" : \"bigint\";\r\n  value: undefined;\r\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\r\n}>;\r\n\r\ntype Numeric<Value extends number | bigint> = Value extends number\r\n  ? Value\r\n  : `BigInt(${Value})`;\r\n\r\n//----\r\n// VALIDATION\r\n//----\r\ninterface Something {\r\n  dollar: string & Dollar;\r\n  postfix: string & Postfix<\"!!!\">;\r\n  isEven: number & IsEven<number>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.assertSomething = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst assertSomething = (input) => {\r\n  const __is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.dollar &&\r\n      input.dollar[0] === \"$\" &&\r\n      !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\r\n      \"string\" === typeof input.postfix &&\r\n      input.postfix.endsWith(\"!!!\") &&\r\n      \"number\" === typeof input.isEven &&\r\n      input.isEven % 2 === 0\r\n    );\r\n  };\r\n  if (false === __is(input))\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $guard = typia_1.default.createAssert.guard;\r\n      const $ao0 = (input, _path, _exceptionable = true) =>\r\n        ((\"string\" === typeof input.dollar &&\r\n          ((input.dollar[0] === \"$\" &&\r\n            !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\")))) ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".dollar\",\r\n              expected: \"string & Dollar\",\r\n              value: input.dollar,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".dollar\",\r\n            expected: \"(string & Dollar)\",\r\n            value: input.dollar,\r\n          })) &&\r\n        ((\"string\" === typeof input.postfix &&\r\n          (input.postfix.endsWith(\"!!!\") ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".postfix\",\r\n              expected: 'string & Postfix<\"!!!\">',\r\n              value: input.postfix,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".postfix\",\r\n            expected: '(string & Postfix<\"!!!\">)',\r\n            value: input.postfix,\r\n          })) &&\r\n        ((\"number\" === typeof input.isEven &&\r\n          (input.isEven % 2 === 0 ||\r\n            $guard(_exceptionable, {\r\n              path: _path + \".isEven\",\r\n              expected: \"number & IsEven<number>\",\r\n              value: input.isEven,\r\n            }))) ||\r\n          $guard(_exceptionable, {\r\n            path: _path + \".isEven\",\r\n            expected: \"(number & IsEven<number>)\",\r\n            value: input.isEven,\r\n          }));\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $guard(true, {\r\n            path: _path + \"\",\r\n            expected: \"Something\",\r\n            value: input,\r\n          })) &&\r\n          $ao0(input, _path + \"\", true)) ||\r\n        $guard(true, {\r\n          path: _path + \"\",\r\n          expected: \"Something\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  return input;\r\n};\r\nexports.assertSomething = assertSomething;","performance#Performance":"Super-fast and super-safe.Comparing typia.assert<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/docs/validators/is":{"title":"Is","data":{"is-function#is() function":"export function is<T>(input: T): input is T;\r\nexport function is<T>(input: unknown): input is T;\nTests a value type.When you need to test an instance type, just call typia.is<T>() function.If the input value is following type T, true value would be returned. Otherwise, false would be returned.\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\nimport typia, { tags } from \"typia\";\r\nimport { v4 } from \"uuid\";\r\n\r\nconst matched: boolean = typia.is<IMember>({\r\n  id: v4(),\r\n  email: \"samchon.github@gmai19l.com\",\r\n  age: 30,\r\n});\r\n\r\nconsole.log(matched); // true\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst uuid_1 = require(\"uuid\");\r\nconst matched = ((input) => {\r\n  return (\r\n    \"object\" === typeof input &&\r\n    null !== input &&\r\n    \"string\" === typeof input.id &&\r\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n      input.id,\r\n    ) &&\r\n    \"string\" === typeof input.email &&\r\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n      input.email,\r\n    ) &&\r\n    \"number\" === typeof input.age &&\r\n    Math.floor(input.age) === input.age &&\r\n    0 <= input.age &&\r\n    input.age <= 4294967295 &&\r\n    19 < input.age &&\r\n    input.age <= 100\r\n  );\r\n})({\r\n  id: (0, uuid_1.v4)(),\r\n  email: \"samchon.github@gmai19l.com\",\r\n  age: 30,\r\n});\r\nconsole.log(matched); // true","equals-function#equals() function":"export function equals<T>(input: T): input is T;\r\nexport function equals<T>(input: unknown): input is T;\nMore strict checker prohibiting superfluous properties.typia.is<T>() can test instance type, but it allows superfluous properties.If you want to prohibit those superfluous properties, you can use typia.equals<T>() function instead.\nimport typia, { tags } from \"typia\";\r\nimport { v4 } from \"uuid\";\r\n\r\nconst input: unknown = {\r\n  id: v4(),\r\n  email: \"samchon.github@gmail.com\",\r\n  age: 30,\r\n  extra: \"superfluous property\", // extra\r\n};\r\nconst is: boolean = typia.is<IMember>(input);\r\nconst equals: boolean = typia.equals<IMember>(input);\r\n\r\nconsole.log(is, equals); // true, false\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst uuid_1 = require(\"uuid\");\r\nconst input = {\r\n  id: (0, uuid_1.v4)(),\r\n  email: \"samchon.github@gmail.com\",\r\n  age: 30,\r\n  extra: \"superfluous property\", // extra\r\n};\r\nconst is = ((input) => {\r\n  return (\r\n    \"object\" === typeof input &&\r\n    null !== input &&\r\n    \"string\" === typeof input.id &&\r\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n      input.id,\r\n    ) &&\r\n    \"string\" === typeof input.email &&\r\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n      input.email,\r\n    ) &&\r\n    \"number\" === typeof input.age &&\r\n    Math.floor(input.age) === input.age &&\r\n    0 <= input.age &&\r\n    input.age <= 4294967295 &&\r\n    19 < input.age &&\r\n    input.age <= 100\r\n  );\r\n})(input);\r\nconst equals = ((input, _exceptionable = true) => {\r\n  const $io0 = (input, _exceptionable = true) =>\r\n    \"string\" === typeof input.id &&\r\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n      input.id,\r\n    ) &&\r\n    \"string\" === typeof input.email &&\r\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n      input.email,\r\n    ) &&\r\n    \"number\" === typeof input.age &&\r\n    Math.floor(input.age) === input.age &&\r\n    0 <= input.age &&\r\n    input.age <= 4294967295 &&\r\n    19 < input.age &&\r\n    input.age <= 100 &&\r\n    (3 === Object.keys(input).length ||\r\n      Object.keys(input).every((key) => {\r\n        if ([\"id\", \"email\", \"age\"].some((prop) => key === prop)) return true;\r\n        const value = input[key];\r\n        if (undefined === value) return true;\r\n        return false;\r\n      }));\r\n  return \"object\" === typeof input && null !== input && $io0(input, true);\r\n})(input);\r\nconsole.log(is, equals); // true, false","reusable-functions#Reusable functions":"export function createIs<T>(): (input: unknown) => input is T;\r\nexport function createEquals<T>(): (input: unknown) => input is T;\nReusable typia.is<T>() function generators.If you repeat to call typia.is<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIs<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const check = typia.createIs<IMember>();\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.check = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst check = (input) => {\r\n  return (\r\n    \"object\" === typeof input &&\r\n    null !== input &&\r\n    \"string\" === typeof input.id &&\r\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n      input.id,\r\n    ) &&\r\n    \"string\" === typeof input.email &&\r\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n      input.email,\r\n    ) &&\r\n    \"number\" === typeof input.age &&\r\n    Math.floor(input.age) === input.age &&\r\n    0 <= input.age &&\r\n    input.age <= 4294967295 &&\r\n    19 < input.age &&\r\n    input.age <= 100\r\n  );\r\n};\r\nexports.check = check;","auto-type-casting#Auto Type Casting":"export function is<T>(input: unknown): input is T;\r\nexport function equals<T>(input: unknown): input is T;\r\nexport function createIs<T>(): (input: unknown) => input is T;\r\nexport function createEquals<T>(): (input: unknown) => input is T;\ntypia.is<T>() function can be used for type casting.When target input value is following the type T, therefore true value be returned, typia.is<T>() function automatically casts the input value to the type T. Therefore, you can utilize the typia.is<T>() function for safe type casting tool like below:\nconst input: unknown = {\r\n  id: v4(),\r\n  email: \"samchon.github@gmail.com\",\r\n  age: 30,\r\n} as any;\r\n\r\nif (typia.is<IMember>(input)) {\r\n  // auto type casting\r\n  console.log(input.id, input.email, input.age);\r\n}","restrictions#Restrictions":"typia.is<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.is<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.is<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\r\n  \"compilerOptions\": {\r\n    \"plugins\": [\r\n      {\r\n        \"transform\": \"typia/lib/transform\",\r\n        \"functional\": true\r\n      }\r\n    ]\r\n  }\r\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.is<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.is<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.\nimport typia from \"typia\";\r\n\r\ntypia.createIs<Map<string, boolean | number | string>>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  return (\r\n    input instanceof Map &&\r\n    (() =>\r\n      [...input].every(\r\n        (elem) =>\r\n          Array.isArray(elem) &&\r\n          elem.length === 2 &&\r\n          \"string\" === typeof elem[0] &&\r\n          (\"string\" === typeof elem[1] ||\r\n            \"number\" === typeof elem[1] ||\r\n            \"boolean\" === typeof elem[1]),\r\n      ))()\r\n  );\r\n};","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSomething = typia.createIs<Something>();\r\n\r\n//----\r\n// DEFINE CUSTOM TYPE TAGS\r\n//----\r\ntype Dollar = tags.TagBase<{\r\n  kind: \"dollar\";\r\n  target: \"string\";\r\n  value: undefined;\r\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\r\n}>;\r\n\r\ntype Postfix<Value extends string> = tags.TagBase<{\r\n  kind: \"postfix\";\r\n  target: \"string\";\r\n  value: Value;\r\n  validate: `$input.endsWith(\"${Value}\")`;\r\n}>;\r\n\r\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\r\n  kind: \"isEven\";\r\n  target: Value extends number ? \"number\" : \"bigint\";\r\n  value: undefined;\r\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\r\n}>;\r\n\r\ntype Numeric<Value extends number | bigint> = Value extends number\r\n  ? Value\r\n  : `BigInt(${Value})`;\r\n\r\n//----\r\n// VALIDATION\r\n//----\r\ninterface Something {\r\n  dollar: string & Dollar;\r\n  postfix: string & Postfix<\"!!!\">;\r\n  isEven: number & IsEven<number>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSomething = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSomething = (input) => {\r\n  return (\r\n    \"object\" === typeof input &&\r\n    null !== input &&\r\n    \"string\" === typeof input.dollar &&\r\n    input.dollar[0] === \"$\" &&\r\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\r\n    \"string\" === typeof input.postfix &&\r\n    input.postfix.endsWith(\"!!!\") &&\r\n    \"number\" === typeof input.isEven &&\r\n    input.isEven % 2 === 0\r\n  );\r\n};\r\nexports.checkSomething = checkSomething;","performance#Performance":"Super-fast and super-safe.Comparing typia.is<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/docs/validators/tags":{"title":"Tags","data":{"outline#Outline":"typia can perform additional validation through type tags and comment tags.When you need additional validation logic that is not supported in pure TypeScript type spec, you can use type tags and comment tags for it. For example, if you define a type with intersection symbol like number & typia.tags.Type<\"uint32\"> and validates it, typia will check the target numeric value is unsigned integer or not.Also, in TypeScript (and JavaScript), writing @ character in comment is called Comment Tag and typia utilizes such comment tags for enhancing type validation logic. As you can see from below example code, typia analyzes @tagName value patterned comment tags, and generates optimal validation logic in the compilation level.Therefore, don't be afraid typia uses only pure TypeScript types for type validation schema. Don't be afraid about TypeScript does not support integer type. With those type tags and comment tags, you can express every types in the world.\nQ: How to validate integer type? TypeScript does not support it\nA1: Use type tag number & typia.tags.Type<\"int32\">\nA2: Write a comment tag @type int32 on the target property\nQ: Type Tag vs Comment Tags, which one is better\nA1: Type Tag is recommended because it is much safer and generous\nA2: Comment Tag is designed for legacy JSDoc styled projects\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkCustomTag = typia.createIs<CustomTag>();\r\n\r\ninterface CustomTag {\r\n  /**\r\n   * @type uint32\r\n   */\r\n  type: number;\r\n\r\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n\r\n  /**\r\n   * @minLength 3\r\n   */\r\n  string: string;\r\n\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n\r\n  /**\r\n   * Type tag can perform union type.\r\n   *\r\n   * In here case, format can be oneof `ipv4` or `ipv6` format.\r\n   */\r\n  format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\r\n\r\n  /**\r\n   * In the Array case, only type tag can restrict element type.\r\n   */\r\n  array: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n\r\n  /**\r\n   * Also, only type tag can handle map type.\r\n   */\r\n  map: Map<\r\n    number & tags.Type<\"uint32\">,\r\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\r\n  >;\r\n}\n----------------------------------------------------------- */\r\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkCustomTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkCustomTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.type &&\r\n    Math.floor(input.type) === input.type &&\r\n    0 <= input.type &&\r\n    input.type <= 4294967295 &&\r\n    (undefined === input.number ||\r\n      (\"number\" === typeof input.number &&\r\n        19 < input.number &&\r\n        input.number <= 100)) &&\r\n    \"string\" === typeof input.string &&\r\n    3 <= input.string.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.format ||\r\n      (\"string\" === typeof input.format &&\r\n        (/^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/.test(\r\n          input.format,\r\n        ) ||\r\n          /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))$/i.test(\r\n            input.format,\r\n          )))) &&\r\n    Array.isArray(input.array) &&\r\n    3 <= input.array.length &&\r\n    input.array.length <= 100 &&\r\n    input.array.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n          elem,\r\n        ),\r\n    ) &&\r\n    input.map instanceof Map &&\r\n    (() =>\r\n      [...input.map].every(\r\n        (elem) =>\r\n          Array.isArray(elem) &&\r\n          elem.length === 2 &&\r\n          \"number\" === typeof elem[0] &&\r\n          Math.floor(elem[0]) === elem[0] &&\r\n          0 <= elem[0] &&\r\n          elem[0] <= 4294967295 &&\r\n          Array.isArray(elem[1]) &&\r\n          1 <= elem[1].length &&\r\n          elem[1].every(\r\n            (elem) =>\r\n              \"string\" === typeof elem &&\r\n              /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n                elem,\r\n              ),\r\n          ),\r\n      ))();\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkCustomTag = checkCustomTag;","type-tags#Type Tags":"By using type tags, you can utilize additional validation logics.Just import one of type tags from typia, and combine it with target through intersection symbol like number & typia.tags.Type<\"uint32\"> case. If you want to declare an union validation logic, combine | and bracket (()) symbols properly like below:\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64\nHere is the entire list of type tags that typia basically supports.For reference, when you take a mistake that choosing different target type, TypeScript compiler would block it with compilation error message. Also, if you take a mistake that placing invalid argument on the type, it would also be blocked IDE and compiler. Therefore, have a confidence when using them.\nnumber\nnumber & Type<{keyword}>\nint32\nuint32\nuint64\nint64\nfloat\ndouble\nnumber & Minimum<{number}>\nnumber & Maximum<{number}>\nnumber & ExclusiveMaximum<{number}>\nnumber & ExclusiveMinimum<{number}>\nnumber & MultipleOf<{number}>\nbigint\nbigint & Type<{keyword}>\nint64\nuint64\nbigint & Minimum<{bigint}>\nbigint & Maximum<{bigint}>\nbigint & ExclusiveMaximum<{bigint}>\nbigint & ExclusiveMinimum<{bigint}>\nbigint & MultipleOf<{bigint}>\nstring\nstring & MinLength<{number}>\nstring & MaxLength<{number}>\nstring & Pattern<{regex}>\nstring & Format<{keyword}>\nbyte\npassword\nregex\nuuid\nemail\nhostname\nidn-email\nidn-hostname\niri\niri-reference\nipv4\nipv6\nuri\nuri-reference\nuri-template\nurl\ndate-time\ndate\ntime\nduration\njson-pointer\nrelative-json-pointer\nAlso, if you need custom validation logic, just make it by yourself referencing Customization section. It is easy to define. For such type safety and generous use case reasons even customization supporting, I recommend you to use type tags instead of comment tags, unless you are maintaining a legacy JSDoc styled project.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkCustomTag = typia.createIs<CustomTag>();\r\n\r\ninterface CustomTag {\r\n  type: number & tags.Type<\"uint32\">;\r\n\r\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n\r\n  string: string & tags.MinLength<3>;\r\n\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n\r\n  /**\r\n   * Type tag can perform union type.\r\n   *\r\n   * In here case, format can be oneof `ipv4` or `ipv6` format.\r\n   */\r\n  format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\r\n\r\n  /**\r\n   * In the Array case, only type tag can restrict element type.\r\n   */\r\n  array: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n\r\n  /**\r\n   * Also, only type tag can handle map type.\r\n   */\r\n  map: Map<\r\n    number & tags.Type<\"uint32\">,\r\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\r\n  >;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkCustomTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkCustomTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.type &&\r\n    Math.floor(input.type) === input.type &&\r\n    0 <= input.type &&\r\n    input.type <= 4294967295 &&\r\n    (undefined === input.number ||\r\n      (\"number\" === typeof input.number &&\r\n        19 < input.number &&\r\n        input.number <= 100)) &&\r\n    \"string\" === typeof input.string &&\r\n    3 <= input.string.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.format ||\r\n      (\"string\" === typeof input.format &&\r\n        (/^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/.test(\r\n          input.format,\r\n        ) ||\r\n          /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))$/i.test(\r\n            input.format,\r\n          )))) &&\r\n    Array.isArray(input.array) &&\r\n    3 <= input.array.length &&\r\n    input.array.length <= 100 &&\r\n    input.array.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n          elem,\r\n        ),\r\n    ) &&\r\n    input.map instanceof Map &&\r\n    (() =>\r\n      [...input.map].every(\r\n        (elem) =>\r\n          Array.isArray(elem) &&\r\n          elem.length === 2 &&\r\n          \"number\" === typeof elem[0] &&\r\n          Math.floor(elem[0]) === elem[0] &&\r\n          0 <= elem[0] &&\r\n          elem[0] <= 4294967295 &&\r\n          Array.isArray(elem[1]) &&\r\n          1 <= elem[1].length &&\r\n          elem[1].every(\r\n            (elem) =>\r\n              \"string\" === typeof elem &&\r\n              /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n                elem,\r\n              ),\r\n          ),\r\n      ))();\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkCustomTag = checkCustomTag;","comment-tags#Comment Tags":"typia supports those comment tags, too.Here is the entire list of comment tags that typia supports.\nnumber\n@type {string}\nint / int32\nuint / uint32\nint64\nuint64\nfloat\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\nbigint\n@type uint64\n@minimum {bigint}\n@maximum {bigint}\n@exclusiveMinimum {bigint}\n@exclusiveMaximum {bigint}\n@multipleOf {bigint}\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nbyte\npassword\nregex\nuuid\nemail\nhostname\nidn-email\nidn-hostname\niri\niri-reference\nipv4\nipv6\nuri\nuri-reference\nuri-template\nurl\ndate-time\ndate\ntime\nduration\njson-pointer\nrelative-json-pointer\narray\n@minItems {number}\n@maxItems {number}\nBy the way, I do not recommend this way, because it can't perform union numeric types, and can be used for only object property type. It can't be used standalone, and cannot be used for element type of Array and Map even when they're declared on object property. Also, When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a mis-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.\nimport typia from \"typia\";\r\n\r\nexport const checkCustomTag = typia.createIs<CustomTag>();\r\n\r\ninterface CustomTag {\r\n  /**\r\n   * @type uint32\r\n   */\r\n  type: number;\r\n\r\n  /**\r\n   * @exclusiveMinimum 19\r\n   * @maximum 100\r\n   */\r\n  number?: number;\r\n\r\n  /**\r\n   * @minLength 3\r\n   */\r\n  string: string;\r\n\r\n  /**\r\n   * @Pattern /^[a-z]+$/\r\n   */\r\n  pattern: string;\r\n\r\n  // NO WAY WHEN COMMENT TAG\r\n  // /**\r\n  //  * Type tag can perform union type.\r\n  //  *\r\n  //  * In here case, format can be oneof `ipv4` or `ipv6` format.\r\n  //  */\r\n  // format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\r\n\r\n  // NO WAY WHEN COMMENT TAG\r\n  // /**\r\n  //  * In the Array case, only type tag can restrict element type.\r\n  //  */\r\n  // array: Array<string & tags.Format<\"uuid\">>\r\n  //     & tags.MinItems<3>\r\n  //     & tags.MaxItems<100>;\r\n\r\n  // NO WAY WHEN COMMENT TAG\r\n  // /**\r\n  //  * Also, only type tag can handle map type.\r\n  //  */\r\n  // map: Map<\r\n  //     number & tags.Type<\"uint32\">,\r\n  //     Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\r\n  // >;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkCustomTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkCustomTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.type &&\r\n    Math.floor(input.type) === input.type &&\r\n    0 <= input.type &&\r\n    input.type <= 4294967295 &&\r\n    (undefined === input.number ||\r\n      (\"number\" === typeof input.number &&\r\n        19 < input.number &&\r\n        input.number <= 100)) &&\r\n    \"string\" === typeof input.string &&\r\n    3 <= input.string.length &&\r\n    \"string\" === typeof input.pattern;\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkCustomTag = checkCustomTag;","customization#Customization":"export type TagBase<Props extends TagBase.IProps<any, any, any, any, any>> = {\r\n  /**\r\n   * This is a dummy property for compilation.\r\n   *\r\n   * It does not mean anything in runtime.\r\n   */\r\n  \"typia.tag\"?: Props;\r\n};\r\nexport namespace TagBase {\r\n  export interface IProps<\r\n    Target extends \"bigint\" | \"number\" | \"string\" | \"array\",\r\n    Kind extends string,\r\n    Value extends boolean | bigint | number | string | undefined,\r\n    Validate extends\r\n      | string\r\n      | {\r\n          [key in Target]?: string;\r\n        },\r\n    Exclusive extends boolean | string[],\r\n  > {\r\n    /**\r\n     * Target type.\r\n     *\r\n     * If user tries to adapt this tag to a different type, it would be a compile\r\n     * error.\r\n     *\r\n     * For example, you've configured target type as `string`, but user adapted it\r\n     * onto a `number` type (`number & YourCustomTag<Value>`), then it would be\r\n     * blocked by TypeScript compiler.\r\n     */\r\n    target: Target;\r\n\r\n    /**\r\n     * What kind of tag is this?\r\n     */\r\n    kind: Kind;\r\n\r\n    /**\r\n     * Value to be configured by user.\r\n     */\r\n    value: Value;\r\n\r\n    /**\r\n     * Validation code.\r\n     *\r\n     * This code would be inserted into the generated validation function.\r\n     * In here script, target variable name must be `$input`. The variable name\r\n     * `$input` would be transformed to the suitable when compilation.\r\n     *\r\n     * Also, If you've take a mistake on this script, compile error would be\r\n     * occured. So, define it with confidence. Compiler will block all your\r\n     * mistakes.\r\n     */\r\n    validate: Validate;\r\n\r\n    /**\r\n     * Exclusive option.\r\n     *\r\n     * If this property configured as `true`, same {@link kind} tag cannot be\r\n     * duplicated in the target type. Otherwise, if you've configured this property\r\n     * as string array, all of the {@link kind} value assigned tag cannot be\r\n     * compatible in the target type.\r\n     *\r\n     * @default false\r\n     */\r\n    exclusive?: Exclusive | string[];\r\n  }\r\n}\nimport { TagBase } from \"./TagBase\";\r\n\r\nexport type Minimum<Value extends number | bigint> = TagBase<{\r\n  target: Value extends number ? \"number\" : \"bigint\";\r\n  kind: \"minimum\";\r\n  value: Value;\r\n  validate: `${Numeric<Value>} <= $input`;\r\n  exclusive: [\"minimum\", \"exclusiveMinimum\"];\r\n}>;\r\n\r\ntype Numeric<Value extends number | bigint> = Value extends number\r\n  ? Value\r\n  : `BigInt(${Value})`;\nimport { TagBase } from \"./TagBase\";\r\n\r\nexport type Type<\r\n  Value extends \"int32\" | \"uint32\" | \"int64\" | \"uint64\" | \"float\" | \"double\",\r\n> = TagBase<{\r\n  target: Value extends \"int64\" | \"uint64\" ? \"bigint\" | \"number\" : \"number\";\r\n  kind: \"type\";\r\n  value: Value;\r\n  validate: Value extends \"int32\"\r\n    ? `Math.floor($input) === $input && -2147483648 <= $input && $input <= 2147483647`\r\n    : Value extends \"uint32\"\r\n    ? `Math.floor($input) === $input && 0 <= $input && $input <= 4294967295`\r\n    : Value extends \"int64\"\r\n    ? {\r\n        number: `Math.floor($input) === $input && -9223372036854775808 <= $input && $input <= 9223372036854775807`;\r\n        bigint: `true`;\r\n      }\r\n    : Value extends \"uint64\"\r\n    ? {\r\n        number: `Math.floor($input) === $input && 0 <= $input && $input <= 18446744073709551615`;\r\n        bigint: `BigInt(0) <= $input`;\r\n      }\r\n    : Value extends \"float\"\r\n    ? `-1.175494351e38 <= $input && $input <= 3.4028235e38`\r\n    : `true`;\r\n  exclusive: true;\r\n}>;\nimport { TagBase } from \"./TagBase\";\r\n\r\nexport type Pattern<Value extends string> = TagBase<{\r\n  target: \"string\";\r\n  kind: \"pattern\";\r\n  value: Value;\r\n  validate: `/${Value}/.test($input)`;\r\n}>;\nAbove types are supported by typia basically.If you make a custom type tag extending typia.tags.TagBase<Props> type, and utilize it on your type with intersection symbol like number & Minimum<3>, its validation logic 3 <= $input would be inserted into the compiled JavaScript file.Also, as you can see from the typia.tags.TagBase<Props> type, you have to specify which target type is the tag for, and need to define the tag can be compatible with others or not through exclusive options. If your custom tag has multiple target types, you can support all of those target types by defining validate property as Record<Target, string> type like Type tag case.In the Korean proverb, there's a word that, \"it is much better to do it once than to hear it a hundred times\". Let's see how custom type tag of typia can be defined and utilized through an example code. I'll define three custom tag types, Postfix, Dollar and IsEven.Here is the example code, and I think that it may easy to understand.\nimport typia from \"typia\";\r\n\r\nexport const checkTagCustom = typia.createIs<TagCustom>();\r\n\r\ninterface TagCustom {\r\n  id: string & typia.tags.Format<\"uuid\">;\r\n  dollar: string & Dolloar;\r\n  postfix: string & Postfix<\"abcd\">;\r\n  powerOf: number & PowerOf<2>;\r\n}\r\n\r\ntype Dolloar = typia.tags.TagBase<{\r\n  kind: \"dollar\";\r\n  target: \"string\";\r\n  value: undefined;\r\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\r\n}>;\r\n\r\ntype Postfix<Value extends string> = typia.tags.TagBase<{\r\n  kind: \"postfix\";\r\n  target: \"string\";\r\n  value: Value;\r\n  validate: `$input.endsWith(\"${Value}\")`;\r\n}>;\r\n\r\ntype PowerOf<Value extends number> = typia.tags.TagBase<{\r\n  kind: \"powerOf\";\r\n  target: \"number\";\r\n  value: Value;\r\n  validate: `(() => {\r\n        const denominator: number = Math.log(${Value});\r\n        const value: number = Math.log($input) / denominator;\r\n        return Math.abs(value - Math.round(value)) < 0.00000001;\r\n    })()`;\r\n}>;\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkTagCustom = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkTagCustom = (input) => {\r\n  return (\r\n    \"object\" === typeof input &&\r\n    null !== input &&\r\n    \"string\" === typeof input.id &&\r\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n      input.id,\r\n    ) &&\r\n    \"string\" === typeof input.dollar &&\r\n    input.dollar[0] === \"$\" &&\r\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\r\n    \"string\" === typeof input.postfix &&\r\n    input.postfix.endsWith(\"abcd\") &&\r\n    \"number\" === typeof input.powerOf &&\r\n    (() => {\r\n      const denominator = Math.log(2);\r\n      const value = Math.log(input.powerOf) / denominator;\r\n      return Math.abs(value - Math.round(value)) < 1e-8;\r\n    })()\r\n  );\r\n};\r\nexports.checkTagCustom = checkTagCustom;"}},"/docs/validators/validate":{"title":"Validate","data":{"validate-function#validate() function":"export function validate<T>(input: T): IValidation<T>;\r\nexport function validate<T>(input: unknown): IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nValidates a value type.typia.validate<T>() function validates input value type, and archives every type errors detaily into IValidation.IFailure.errors array, when the input value is not following the promised type T. Of course, if the parametric input value is following the type T, IValidation.ISuccess instance would be returned.In the below example case, as id and age values are different with its definition of IMember, such errors would be archived into the IValidation.IFailure.errors array.\nerrors[0]\npath: input.id\nexpected: string & Format<\"uuid\">\nvalue: 5\nerrors[1]\npath: input.age\nexpected: number & Format<\"uint32\">\nvalue: 20.75\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\nimport typia, { tags } from \"typia\";\r\n\r\nconst res: typia.IValidation<IMember> = typia.validate<IMember>({\r\n  id: 5, // wrong, must be string (uuid)\r\n  age: 20.75, // wrong, not integer\r\n  email: \"samchon.github@gmail.com\",\r\n});\r\n\r\nif (!res.success) console.log(res.errors);\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst res = ((input) => {\r\n  const errors = [];\r\n  const __is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.email &&\r\n      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n        input.email,\r\n      ) &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100\r\n    );\r\n  };\r\n  if (false === __is(input)) {\r\n    const $report = typia_1.default.validate.report(errors);\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $vo0 = (input, _path, _exceptionable = true) =>\r\n        [\r\n          (\"string\" === typeof input.id &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input.id,\r\n            ) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".id\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input.id,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: '(string & Format<\"uuid\">)',\r\n              value: input.id,\r\n            }),\r\n          (\"string\" === typeof input.email &&\r\n            (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n              input.email,\r\n            ) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".email\",\r\n                expected: 'string & Format<\"email\">',\r\n                value: input.email,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".email\",\r\n              expected: '(string & Format<\"email\">)',\r\n              value: input.email,\r\n            }),\r\n          (\"number\" === typeof input.age &&\r\n            ((Math.floor(input.age) === input.age &&\r\n              0 <= input.age &&\r\n              input.age <= 4294967295) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: 'number & Type<\"uint32\">',\r\n                value: input.age,\r\n              })) &&\r\n            (19 < input.age ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & ExclusiveMinimum<19>\",\r\n                value: input.age,\r\n              })) &&\r\n            (input.age <= 100 ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & Maximum<100>\",\r\n                value: input.age,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected:\r\n                '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n              value: input.age,\r\n            }),\r\n        ].every((flag) => flag);\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $report(true, {\r\n            path: _path + \"\",\r\n            expected: \"IMember\",\r\n            value: input,\r\n          })) &&\r\n          $vo0(input, _path + \"\", true)) ||\r\n        $report(true, {\r\n          path: _path + \"\",\r\n          expected: \"IMember\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  }\r\n  const success = 0 === errors.length;\r\n  return {\r\n    success,\r\n    errors,\r\n    data: success ? input : undefined,\r\n  };\r\n})({\r\n  id: 5, // wrong, must be string (uuid)\r\n  age: 20.75, // wrong, not integer\r\n  email: \"samchon.github@gmail.com\",\r\n});\r\nif (!res.success) console.log(res.errors);","validateequals-function#validateEquals() function":"export function validateEquals<T>(input: T): IValidation<T>;\r\nexport function validateEquals<T>(input: unknown): IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nMore strict validatae function prohibiting superfluous properties.typia.validate<T> function detects every type errors of input value, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, so that archive them into IValidation.IFailure.errors array, use typia.validateEquals<T>() function instead.In the below example case, as id property is different with its type definition and sex property is not defined in the IMember type, such errors would be archived into the IValidation.IFailure.errors array:\nerrors[0]\npath: input.id\nexpected: string (@format uuid)\nvalue: something\nerrors[1]\npath: input.sex\nexpected: undefined\nvalue: 1\nimport typia, { tags } from \"typia\";\r\n\r\nconst res: typia.IValidation<IMember> = typia.validateEquals<IMember>({\r\n  age: 30,\r\n  email: \"samchon.github@gmail.com\",\r\n  id: \"something\", // wrong, must be string (uuid)\r\n  sex: 1, // extra property\r\n});\r\n\r\nif (!res.success) console.log(res.errors);\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst res = ((input) => {\r\n  const errors = [];\r\n  const __is = (input, _exceptionable = true) => {\r\n    const $io0 = (input, _exceptionable = true) =>\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.email &&\r\n      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n        input.email,\r\n      ) &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100 &&\r\n      (3 === Object.keys(input).length ||\r\n        Object.keys(input).every((key) => {\r\n          if ([\"id\", \"email\", \"age\"].some((prop) => key === prop)) return true;\r\n          const value = input[key];\r\n          if (undefined === value) return true;\r\n          return false;\r\n        }));\r\n    return \"object\" === typeof input && null !== input && $io0(input, true);\r\n  };\r\n  if (false === __is(input)) {\r\n    const $report = typia_1.default.validateEquals.report(errors);\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $join = typia_1.default.validateEquals.join;\r\n      const $vo0 = (input, _path, _exceptionable = true) =>\r\n        [\r\n          (\"string\" === typeof input.id &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input.id,\r\n            ) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".id\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input.id,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: '(string & Format<\"uuid\">)',\r\n              value: input.id,\r\n            }),\r\n          (\"string\" === typeof input.email &&\r\n            (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n              input.email,\r\n            ) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".email\",\r\n                expected: 'string & Format<\"email\">',\r\n                value: input.email,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".email\",\r\n              expected: '(string & Format<\"email\">)',\r\n              value: input.email,\r\n            }),\r\n          (\"number\" === typeof input.age &&\r\n            ((Math.floor(input.age) === input.age &&\r\n              0 <= input.age &&\r\n              input.age <= 4294967295) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: 'number & Type<\"uint32\">',\r\n                value: input.age,\r\n              })) &&\r\n            (19 < input.age ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & ExclusiveMinimum<19>\",\r\n                value: input.age,\r\n              })) &&\r\n            (input.age <= 100 ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & Maximum<100>\",\r\n                value: input.age,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected:\r\n                '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n              value: input.age,\r\n            }),\r\n          3 === Object.keys(input).length ||\r\n            false === _exceptionable ||\r\n            Object.keys(input)\r\n              .map((key) => {\r\n                if ([\"id\", \"email\", \"age\"].some((prop) => key === prop))\r\n                  return true;\r\n                const value = input[key];\r\n                if (undefined === value) return true;\r\n                return $report(_exceptionable, {\r\n                  path: _path + $join(key),\r\n                  expected: \"undefined\",\r\n                  value: value,\r\n                });\r\n              })\r\n              .every((flag) => flag),\r\n        ].every((flag) => flag);\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $report(true, {\r\n            path: _path + \"\",\r\n            expected: \"IMember\",\r\n            value: input,\r\n          })) &&\r\n          $vo0(input, _path + \"\", true)) ||\r\n        $report(true, {\r\n          path: _path + \"\",\r\n          expected: \"IMember\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  }\r\n  const success = 0 === errors.length;\r\n  return {\r\n    success,\r\n    errors,\r\n    data: success ? input : undefined,\r\n  };\r\n})({\r\n  age: 30,\r\n  email: \"samchon.github@gmail.com\",\r\n  id: \"something\", // wrong, must be string (uuid)\r\n  sex: 1, // extra property\r\n});\r\nif (!res.success) console.log(res.errors);","reusable-functions#Reusable functions":"export function createValidate<T> = (input: unknown) => IValidation<T>;\r\nexport function createValidateEquals<T> = (input: unknown) => IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nReusable typia.validate<T>() function generators.If you repeat to call typia.validate<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createValidate<T>() function.Just look at the code below, then you may understand how to use it.\nimport typia, { tags } from \"typia\";\r\n\r\nexport const validateMember = typia.createValidate<IMember>();\r\n\r\ninterface IMember {\r\n  id: string & tags.Format<\"uuid\">;\r\n  email: string & tags.Format<\"email\">;\r\n  age: number &\r\n    tags.Type<\"uint32\"> &\r\n    tags.ExclusiveMinimum<19> &\r\n    tags.Maximum<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.validateMember = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst validateMember = (input) => {\r\n  const errors = [];\r\n  const __is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.id &&\r\n      /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n        input.id,\r\n      ) &&\r\n      \"string\" === typeof input.email &&\r\n      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n        input.email,\r\n      ) &&\r\n      \"number\" === typeof input.age &&\r\n      Math.floor(input.age) === input.age &&\r\n      0 <= input.age &&\r\n      input.age <= 4294967295 &&\r\n      19 < input.age &&\r\n      input.age <= 100\r\n    );\r\n  };\r\n  if (false === __is(input)) {\r\n    const $report = typia_1.default.createValidate.report(errors);\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $vo0 = (input, _path, _exceptionable = true) =>\r\n        [\r\n          (\"string\" === typeof input.id &&\r\n            (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n              input.id,\r\n            ) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".id\",\r\n                expected: 'string & Format<\"uuid\">',\r\n                value: input.id,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".id\",\r\n              expected: '(string & Format<\"uuid\">)',\r\n              value: input.id,\r\n            }),\r\n          (\"string\" === typeof input.email &&\r\n            (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\r\n              input.email,\r\n            ) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".email\",\r\n                expected: 'string & Format<\"email\">',\r\n                value: input.email,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".email\",\r\n              expected: '(string & Format<\"email\">)',\r\n              value: input.email,\r\n            }),\r\n          (\"number\" === typeof input.age &&\r\n            ((Math.floor(input.age) === input.age &&\r\n              0 <= input.age &&\r\n              input.age <= 4294967295) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: 'number & Type<\"uint32\">',\r\n                value: input.age,\r\n              })) &&\r\n            (19 < input.age ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & ExclusiveMinimum<19>\",\r\n                value: input.age,\r\n              })) &&\r\n            (input.age <= 100 ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".age\",\r\n                expected: \"number & Maximum<100>\",\r\n                value: input.age,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".age\",\r\n              expected:\r\n                '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\r\n              value: input.age,\r\n            }),\r\n        ].every((flag) => flag);\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $report(true, {\r\n            path: _path + \"\",\r\n            expected: \"IMember\",\r\n            value: input,\r\n          })) &&\r\n          $vo0(input, _path + \"\", true)) ||\r\n        $report(true, {\r\n          path: _path + \"\",\r\n          expected: \"IMember\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  }\r\n  const success = 0 === errors.length;\r\n  return {\r\n    success,\r\n    errors,\r\n    data: success ? input : undefined,\r\n  };\r\n};\r\nexports.validateMember = validateMember;","restrictions#Restrictions":"typia.validate<T>() function does not check function and user-defined class types.It validates only the primitive properties. Therefore, typia.validate<T>() function does not perform the instanceof ClassName for user-defined classes. If you want to validate the user-defined class type in addition to the property types, do it by yourself. Also, typia.validate<T>() function does not validate the function type either, unless configuring functional property of plugin option in the tsconfig.json file.\n{\r\n  \"compilerOptions\": {\r\n    \"plugins\": [\r\n      {\r\n        \"transform\": \"typia/lib/transform\",\r\n        \"functional\": true\r\n      }\r\n    ]\r\n  }\r\n}\nBy the way, there're some exception cases.If JS native class type like Date, Uint8Array, or Map<Key, T> being utilized, typia.validate<T>() function validates them. Especially about the Set<T>, and Map<Key, T> class cases, typia.validate<T>() function validates all of their contained element types, too.Therefore, the instanceof statement does not be used only for the user-defined classes.\nimport typia from \"typia\";\r\n\r\ntypia.createIs<Map<string, boolean | number | string>>();\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\n(input) => {\r\n  return (\r\n    input instanceof Map &&\r\n    (() =>\r\n      [...input].every(\r\n        (elem) =>\r\n          Array.isArray(elem) &&\r\n          elem.length === 2 &&\r\n          \"string\" === typeof elem[0] &&\r\n          (\"string\" === typeof elem[1] ||\r\n            \"number\" === typeof elem[1] ||\r\n            \"boolean\" === typeof elem[1]),\r\n      ))()\r\n  );\r\n};","discriminated-union#Discriminated Union":"export function validate<T>(input: T): IValidation<T>;\r\nexport function validate<T>(input: unknown): IValidation<T>;\r\nexport function createValidate<T>(): (input: unknown) => IValidation<T>;\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\r\nexport namespace IValidation {\r\n  export interface ISuccess<T> {\r\n    success: true;\r\n    data: T;\r\n  }\r\n  export interface IFailure {\r\n    success: false;\r\n    errors: IError[];\r\n  }\r\n  export interface IError {\r\n    path: string;\r\n    expected: string;\r\n    value: any;\r\n  }\r\n}\nSpecify type through if condition.typia.IValidation<T> is an union type of typia.IValidation.ISuccess<T> and typia.IValidation.IFailure. Also, they have a common property success of boolean type, but different literal values. In that case, if you write a if condition about the success property, you can specify the union type like below.In TypeScript, such union type specification through common property (of different literal value() is called \"Discriminated Union\". Therefore, when using typia.validate<T>() function, let's utilize such discriminated union specification for convenience.\nimport typia from \"typia\";\r\n\r\nconst something: unknown = ...;\r\nconst result: typia.IValidation<string> = typia.validate<string>(something);\r\n\r\nif (results.success) {\r\n  // become typia.IValidation.Success<string> type\r\n  result.data; // accessible\r\n} else {\r\n  // become typia.IValidation.Failure type\r\n  result.errors; //accessible\r\n}","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const validateSomething = typia.createValidate<Something>();\r\n\r\n//----\r\n// DEFINE CUSTOM TYPE TAGS\r\n//----\r\ntype Dollar = tags.TagBase<{\r\n  kind: \"dollar\";\r\n  target: \"string\";\r\n  value: undefined;\r\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\r\n}>;\r\n\r\ntype Postfix<Value extends string> = tags.TagBase<{\r\n  kind: \"postfix\";\r\n  target: \"string\";\r\n  value: Value;\r\n  validate: `$input.endsWith(\"${Value}\")`;\r\n}>;\r\n\r\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\r\n  kind: \"isEven\";\r\n  target: Value extends number ? \"number\" : \"bigint\";\r\n  value: undefined;\r\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\r\n}>;\r\n\r\ntype Numeric<Value extends number | bigint> = Value extends number\r\n  ? Value\r\n  : `BigInt(${Value})`;\r\n\r\n//----\r\n// VALIDATION\r\n//----\r\ninterface Something {\r\n  dollar: string & Dollar;\r\n  postfix: string & Postfix<\"!!!\">;\r\n  isEven: number & IsEven<number>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.validateSomething = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst validateSomething = (input) => {\r\n  const errors = [];\r\n  const __is = (input) => {\r\n    return (\r\n      \"object\" === typeof input &&\r\n      null !== input &&\r\n      \"string\" === typeof input.dollar &&\r\n      input.dollar[0] === \"$\" &&\r\n      !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\r\n      \"string\" === typeof input.postfix &&\r\n      input.postfix.endsWith(\"!!!\") &&\r\n      \"number\" === typeof input.isEven &&\r\n      input.isEven % 2 === 0\r\n    );\r\n  };\r\n  if (false === __is(input)) {\r\n    const $report = typia_1.default.createValidate.report(errors);\r\n    ((input, _path, _exceptionable = true) => {\r\n      const $vo0 = (input, _path, _exceptionable = true) =>\r\n        [\r\n          (\"string\" === typeof input.dollar &&\r\n            ((input.dollar[0] === \"$\" &&\r\n              !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\")))) ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".dollar\",\r\n                expected: \"string & Dollar\",\r\n                value: input.dollar,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".dollar\",\r\n              expected: \"(string & Dollar)\",\r\n              value: input.dollar,\r\n            }),\r\n          (\"string\" === typeof input.postfix &&\r\n            (input.postfix.endsWith(\"!!!\") ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".postfix\",\r\n                expected: 'string & Postfix<\"!!!\">',\r\n                value: input.postfix,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".postfix\",\r\n              expected: '(string & Postfix<\"!!!\">)',\r\n              value: input.postfix,\r\n            }),\r\n          (\"number\" === typeof input.isEven &&\r\n            (input.isEven % 2 === 0 ||\r\n              $report(_exceptionable, {\r\n                path: _path + \".isEven\",\r\n                expected: \"number & IsEven<number>\",\r\n                value: input.isEven,\r\n              }))) ||\r\n            $report(_exceptionable, {\r\n              path: _path + \".isEven\",\r\n              expected: \"(number & IsEven<number>)\",\r\n              value: input.isEven,\r\n            }),\r\n        ].every((flag) => flag);\r\n      return (\r\n        (((\"object\" === typeof input && null !== input) ||\r\n          $report(true, {\r\n            path: _path + \"\",\r\n            expected: \"Something\",\r\n            value: input,\r\n          })) &&\r\n          $vo0(input, _path + \"\", true)) ||\r\n        $report(true, {\r\n          path: _path + \"\",\r\n          expected: \"Something\",\r\n          value: input,\r\n        })\r\n      );\r\n    })(input, \"$input\", true);\r\n  }\r\n  const success = 0 === errors.length;\r\n  return {\r\n    success,\r\n    errors,\r\n    data: success ? input : undefined,\r\n  };\r\n};\r\nexports.validateSomething = validateSomething;","performance#Performance":"Super-fast and super-safe.Comparing typia.validate<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/docs/utilization/trpc":{"title":"Trpc","data":{"":"import { initTRPC } from \"@trpc/server\";\r\nimport { v4 } from \"uuid\";\r\nimport typia from \"typia\";\r\n\r\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\r\n\r\nconst server = initTRPC.create();\r\n\r\nexport const appRouter = server.router({\r\n  store: server.procedure\r\n    .input(typia.createAssert<IBbsArticle.IStore>())\r\n    .output(typia.createAssert<IBbsArticle>())\r\n    .query(({ input }) => {\r\n      return {\r\n        id: v4(),\r\n        writer: input.writer,\r\n        title: input.title,\r\n        body: input.body,\r\n        created_at: new Date().toString(),\r\n      };\r\n    }),\r\n});\r\nexport type AppRouter = typeof appRouter;"}}}